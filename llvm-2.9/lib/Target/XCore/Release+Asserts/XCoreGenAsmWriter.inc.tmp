//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void XCoreAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    536870923U,	// ADD_2rus
    536870923U,	// ADD_3r
    1107296272U,	// ADJCALLSTACKDOWN
    1140850704U,	// ADJCALLSTACKUP
    545259537U,	// ANDNOT_2r
    536870937U,	// AND_3r
    536870942U,	// ASHR_l2rus
    536870942U,	// ASHR_l3r
    637534244U,	// BAU_1r
    538968105U,	// BITREV_l2r
    637534257U,	// BLA_1r
    637534262U,	// BL_lu10
    637534262U,	// BL_u10
    538968122U,	// BRBF_lru6
    538968122U,	// BRBF_ru6
    538968126U,	// BRBT_lru6
    538968126U,	// BRBT_ru6
    637534274U,	// BRBU_lu6
    637534274U,	// BRBU_u6
    538968122U,	// BRFF_lru6
    538968122U,	// BRFF_ru6
    538968126U,	// BRFT_lru6
    538968126U,	// BRFT_ru6
    637534274U,	// BRFU_lu6
    637534274U,	// BRFU_u6
    1761607750U,	// BR_JT
    1769996358U,	// BR_JT32
    538968139U,	// BYTEREV_l2r
    706740308U,	// CHKCT_2r
    706740308U,	// CHKCT_rus
    95U,	// CLRE_0R
    538968164U,	// CLZ_l2r
    536871017U,	// DIVS_l3r
    536871023U,	// DIVU_l3r
    637534325U,	// ECALLF_1r
    637534333U,	// ECALLT_1r
    738197637U,	// EEU_1r
    637534350U,	// ENTSP_lu6
    637534350U,	// ENTSP_u6
    536871061U,	// EQ_2rus
    536871061U,	// EQ_3r
    637534361U,	// EXTSP_lu6
    637534361U,	// EXTSP_u6
    738197664U,	// FREER_1r
    171U,	// GETID_0R
    538968247U,	// GETR_rus
    771752125U,	// GETTS_2r
    771752132U,	// INCT_2r
    771752138U,	// INSHR_2r
    771752145U,	// INT_2r
    771752150U,	// IN_2r
    537395418U,	// LADD_l5r
    541065440U,	// LD16S_3r
    541065447U,	// LD8U_3r
    543162605U,	// LDA16B_l3r
    541065453U,	// LDA16F_l3r
    637534452U,	// LDAP_lu10
    637534452U,	// LDAP_lu10_ba
    637534452U,	// LDAP_u10
    543162623U,	// LDAWB_l2rus
    543162623U,	// LDAWB_l3r
    2147483909U,	// LDAWCP_lu6
    2147483909U,	// LDAWCP_u6
    805306623U,	// LDAWDP_lru6
    805306623U,	// LDAWDP_ru6
    1375731728U,	// LDAWFI
    541065471U,	// LDAWF_l2rus
    541065471U,	// LDAWF_l3r
    872415487U,	// LDAWSP_lru6
    872415487U,	// LDAWSP_lru6_RRegs
    872415487U,	// LDAWSP_ru6
    872415487U,	// LDAWSP_ru6_RRegs
    538968339U,	// LDC_lru6
    538968339U,	// LDC_ru6
    537395480U,	// LDIV_l5r
    905969950U,	// LDWCP_lru6
    905969950U,	// LDWCP_ru6
    805306654U,	// LDWDP_lru6
    805306654U,	// LDWDP_ru6
    1476395024U,	// LDWFI
    872415518U,	// LDWSP_lru6
    872415518U,	// LDWSP_ru6
    541065502U,	// LDW_2rus
    541065502U,	// LDW_3r
    537657635U,	// LMUL_l6r
    536871209U,	// LSS_3r
    537395502U,	// LSUB_l5r
    536871220U,	// LSU_3r
    537919801U,	// MACCS_l4r
    537919808U,	// MACCU_l4r
    538968391U,	// MKMSK_2r
    538968391U,	// MKMSK_rus
    536871246U,	// MUL_l3r
    538968403U,	// NEG
    538968408U,	// NOT
    536871261U,	// OR_3r
    706740577U,	// OUTCT_2r
    706740577U,	// OUTCT_rus
    1786773868U,	// OUTSHR_2r
    706740600U,	// OUTT_2r
    706740610U,	// OUT_2r
    536871307U,	// REMS_l3r
    536871313U,	// REMU_l3r
    637534615U,	// RETSP_lu6
    637534615U,	// RETSP_u6
    1509949456U,	// SELECT_CC
    706740638U,	// SETC_l2r
    706740638U,	// SETC_lru6
    706740638U,	// SETC_ru6
    706740648U,	// SETD_2r
    706740658U,	// SETPT_2r
    637534653U,	// SETSP_1r
    706740678U,	// SETTW_l2r
    1006633425U,	// SETV_1r
    545259995U,	// SEXT_rus
    536871393U,	// SHL_2rus
    536871393U,	// SHL_3r
    536871398U,	// SHR_2rus
    536871398U,	// SHR_3r
    541065707U,	// ST16_l3r
    541065713U,	// ST8_l3r
    805306870U,	// STWDP_lru6
    805306870U,	// STWDP_ru6
    1577058320U,	// STWFI
    872415734U,	// STWSP_lru6
    872415734U,	// STWSP_ru6
    541065718U,	// STW_2rus
    541065718U,	// STW_3r
    536871419U,	// SUB_2rus
    536871419U,	// SUB_3r
    738198016U,	// SYNCR_1r
    523U,	// WAITEU_0R
    536871442U,	// XOR_l3r
    545260055U,	// ZEXT_rus
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000add \000\000andnot \000and \000ashr \000bau \000bitrev \000"
    "bla \000bl \000bf \000bt \000bu \000bru \000byterev \000chkct res[\000c"
    "lre\000clz \000divs \000divu \000ecallf \000ecallt \000eeu res[\000ents"
    "p \000eq \000extsp \000freer res[\000get r11, id\000getr \000getts \000"
    "inct \000inshr \000int \000in \000ladd \000ld16s \000ld8u \000lda16 \000"
    "ldap r11, \000ldaw \000ldaw r11, cp[\000ldc \000ldiv \000ldw \000lmul \000"
    "lss \000lsub \000lsu \000maccs \000maccu \000mkmsk \000mul \000neg \000"
    "not \000or \000outct res[\000outshr res[\000outt res[\000out res[\000re"
    "ms \000remu \000retsp \000setc res[\000setd res[\000setpt res[\000set s"
    "p, \000settw res[\000setv res[\000sext \000shl \000shr \000st16 \000st8"
    " \000stw \000sub \000syncr res[\000waiteu\000xor \000zext \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, CLRE_0R, GETID_0R, WAITEU_0R
    return;
    break;
  case 1:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, O, "comment"); 
    break;
  case 3:
    // BR_JT, BR_JT32, OUTSHR_2r
    printOperand(MI, 1, O); 
    break;
  case 4:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 16 unique commands.
  switch ((Bits >> 25) & 15) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    return;
    break;
  case 4:
    // BR_JT, BR_JT32
    O << "\n"; 
    break;
  case 5:
    // CHKCT_2r, CHKCT_rus, OUTCT_2r, OUTCT_rus, OUTSHR_2r, OUTT_2r, OUT_2r, ...
    O << "], "; 
    break;
  case 6:
    // EEU_1r, FREER_1r, SYNCR_1r
    O << ']'; 
    return;
    break;
  case 7:
    // GETTS_2r, INCT_2r, INSHR_2r, INT_2r, IN_2r
    O << ", res["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 8:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 9:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 10:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 11:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 12:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 13:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!"; 
    return;
    break;
  case 14:
    // SETV_1r
    O << "], r11"; 
    return;
    break;
  case 15:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 23) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // ANDNOT_2r, OUTSHR_2r, SEXT_rus, ZEXT_rus
    printOperand(MI, 2, O); 
    return;
    break;
  case 2:
    // BR_JT
    printInlineJT(MI, 0, O); 
    return;
    break;
  case 3:
    // BR_JT32
    printInlineJT32(MI, 0, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 21) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    O << ", "; 
    break;
  case 1:
    // BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_lru6, BRFF_...
    return;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '['; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4, O); 
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2, O); 
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 19) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    O << ", "; 
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 4, O); 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    return;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 18) & 1) {
    // LMUL_l6r
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *XCoreAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 17 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 
    43, 47, 0
  };

  const char *AsmStrs =
    "cp\000dp\000lr\000r0\000r1\000r2\000r3\000r4\000r5\000r6\000r7\000r8\000"
    "r9\000r10\000r11\000sp\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *XCoreAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 148 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 160, 167, 184, 199, 209, 216, 227, 236, 243, 254, 261, 269, 276, 
    286, 295, 305, 314, 323, 331, 341, 350, 360, 369, 378, 386, 392, 400, 
    412, 421, 431, 439, 447, 456, 465, 475, 485, 492, 502, 511, 519, 525, 
    535, 544, 553, 562, 571, 580, 588, 597, 604, 610, 619, 628, 636, 647, 
    658, 668, 681, 690, 702, 712, 723, 733, 745, 756, 763, 775, 785, 797, 
    815, 826, 843, 852, 860, 869, 880, 890, 901, 911, 917, 928, 938, 947, 
    954, 963, 970, 979, 986, 996, 1006, 1015, 1025, 1033, 1037, 1041, 1047, 1056, 
    1066, 1076, 1084, 1091, 1100, 1109, 1119, 1128, 1138, 1147, 1157, 1166, 1174, 1183, 
    1192, 1202, 1210, 1219, 1228, 1235, 1244, 1251, 1260, 1268, 1279, 1289, 1295, 1306, 
    1316, 1325, 1332, 1341, 1348, 1357, 1367, 1375, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADD_2rus\000ADD_3r\000"
    "ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000ANDNOT_2r\000AND_3r\000ASHR_l2rus"
    "\000ASHR_l3r\000BAU_1r\000BITREV_l2r\000BLA_1r\000BL_lu10\000BL_u10\000"
    "BRBF_lru6\000BRBF_ru6\000BRBT_lru6\000BRBT_ru6\000BRBU_lu6\000BRBU_u6\000"
    "BRFF_lru6\000BRFF_ru6\000BRFT_lru6\000BRFT_ru6\000BRFU_lu6\000BRFU_u6\000"
    "BR_JT\000BR_JT32\000BYTEREV_l2r\000CHKCT_2r\000CHKCT_rus\000CLRE_0R\000"
    "CLZ_l2r\000DIVS_l3r\000DIVU_l3r\000ECALLF_1r\000ECALLT_1r\000EEU_1r\000"
    "ENTSP_lu6\000ENTSP_u6\000EQ_2rus\000EQ_3r\000EXTSP_lu6\000EXTSP_u6\000F"
    "REER_1r\000GETID_0R\000GETR_rus\000GETTS_2r\000INCT_2r\000INSHR_2r\000I"
    "NT_2r\000IN_2r\000LADD_l5r\000LD16S_3r\000LD8U_3r\000LDA16B_l3r\000LDA1"
    "6F_l3r\000LDAP_lu10\000LDAP_lu10_ba\000LDAP_u10\000LDAWB_l2rus\000LDAWB"
    "_l3r\000LDAWCP_lu6\000LDAWCP_u6\000LDAWDP_lru6\000LDAWDP_ru6\000LDAWFI\000"
    "LDAWF_l2rus\000LDAWF_l3r\000LDAWSP_lru6\000LDAWSP_lru6_RRegs\000LDAWSP_"
    "ru6\000LDAWSP_ru6_RRegs\000LDC_lru6\000LDC_ru6\000LDIV_l5r\000LDWCP_lru"
    "6\000LDWCP_ru6\000LDWDP_lru6\000LDWDP_ru6\000LDWFI\000LDWSP_lru6\000LDW"
    "SP_ru6\000LDW_2rus\000LDW_3r\000LMUL_l6r\000LSS_3r\000LSUB_l5r\000LSU_3"
    "r\000MACCS_l4r\000MACCU_l4r\000MKMSK_2r\000MKMSK_rus\000MUL_l3r\000NEG\000"
    "NOT\000OR_3r\000OUTCT_2r\000OUTCT_rus\000OUTSHR_2r\000OUTT_2r\000OUT_2r"
    "\000REMS_l3r\000REMU_l3r\000RETSP_lu6\000RETSP_u6\000SELECT_CC\000SETC_"
    "l2r\000SETC_lru6\000SETC_ru6\000SETD_2r\000SETPT_2r\000SETSP_1r\000SETT"
    "W_l2r\000SETV_1r\000SEXT_rus\000SHL_2rus\000SHL_3r\000SHR_2rus\000SHR_3"
    "r\000ST16_l3r\000ST8_l3r\000STWDP_lru6\000STWDP_ru6\000STWFI\000STWSP_l"
    "ru6\000STWSP_ru6\000STW_2rus\000STW_3r\000SUB_2rus\000SUB_3r\000SYNCR_1"
    "r\000WAITEU_0R\000XOR_l3r\000ZEXT_rus\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_GRRegs,
    RC_RRegs
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_GRRegs:
    switch (Reg) {
    default: break;
    case XCore::R0:
    case XCore::R1:
    case XCore::R2:
    case XCore::R3:
    case XCore::R11:
    case XCore::R4:
    case XCore::R5:
    case XCore::R6:
    case XCore::R7:
    case XCore::R8:
    case XCore::R9:
    case XCore::R10:
      return true;
    }
    break;
  case RC_RRegs:
    switch (Reg) {
    default: break;
    case XCore::CP:
    case XCore::DP:
    case XCore::SP:
    case XCore::LR:
      return true;
    }
    break;
  }

  return false;
}

bool XCoreAsmPrinter::printAliasInstr(const MachineInstr *MI, raw_ostream &OS) {
  return true;
}

#endif // PRINT_ALIAS_INSTR
