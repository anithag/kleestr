//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MipsAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    536870923U,	// ADD
    536870928U,	// ADDi
    536870934U,	// ADDiu
    536870941U,	// ADDu
    1140850723U,	// ADJCALLSTACKDOWN
    1140850742U,	// ADJCALLSTACKUP
    536870983U,	// AND
    537919564U,	// ANDi
    82U,	// ATMACRO
    603979866U,	// BC1F
    603979872U,	// BC1FL
    603979879U,	// BC1T
    603979885U,	// BC1TL
    536871028U,	// BEQ
    538968185U,	// BGEZ
    538968191U,	// BGEZAL
    538968199U,	// BGTZ
    538968205U,	// BLEZ
    538968211U,	// BLTZ
    538968217U,	// BLTZAL
    536871073U,	// BNE
    538968230U,	// CEIL_LD
    538968230U,	// CEIL_LS
    538968238U,	// CEIL_W_D32
    538968248U,	// CEIL_W_S32
    538968258U,	// CFC1
    538968264U,	// CLO
    538968269U,	// CLZ
    603979986U,	// CPLOAD
    1207959771U,	// CPRESTORE
    1610612967U,	// CTC1
    538968301U,	// CVTD_L32
    538968310U,	// CVTD_S32
    538968319U,	// CVTD_W32
    538968328U,	// CVTL_D
    538968328U,	// CVTL_S
    538968335U,	// CVTS_D32
    538968344U,	// CVTS_L32
    538968353U,	// CVTS_W32
    538968362U,	// CVTW_D32
    538968371U,	// CVTW_S32
    538968380U,	// FABS_D32
    538968387U,	// FABS_S32
    536871242U,	// FADD_D32
    536871249U,	// FADD_S32
    2348810584U,	// FCMP_D32
    2415919448U,	// FCMP_S32
    536871259U,	// FDIV_D32
    536871266U,	// FDIV_S32
    538968425U,	// FLOOR_LD
    538968425U,	// FLOOR_LS
    538968434U,	// FLOOR_W_D32
    538968445U,	// FLOOR_W_S32
    538968456U,	// FMOV_D32
    538968463U,	// FMOV_S32
    536871318U,	// FMUL_D32
    536871325U,	// FMUL_S32
    538968484U,	// FNEG_D32
    538968491U,	// FNEG_S32
    538968498U,	// FSQRT_D32
    538968506U,	// FSQRT_S32
    536871362U,	// FSUB_D32
    536871369U,	// FSUB_S32
    603980240U,	// J
    603980243U,	// JAL
    603980248U,	// JALR
    603980254U,	// JR
    545260002U,	// LB
    545260006U,	// LBu
    545260011U,	// LDC1
    553648150U,	// LEA_ADDiu
    545260017U,	// LH
    545260021U,	// LHu
    562037242U,	// LUi
    545260031U,	// LW
    545260035U,	// LWC1
    521U,	// MACRO
    538968596U,	// MADD
    538968602U,	// MADDU
    538968609U,	// MFC1
    603980327U,	// MFHI
    603980333U,	// MFLO
    563U,	// MOVCCRToCCR
    574620225U,	// MOVN
    574620231U,	// MOVZ
    538968653U,	// MSUB
    538968659U,	// MSUBU
    1610613338U,	// MTC1
    603980384U,	// MTHI
    603980390U,	// MTLO
    536871532U,	// MUL
    538968689U,	// MULT
    538968695U,	// MULTu
    638U,	// NOAT
    648U,	// NOMACRO
    661U,	// NOP
    536871577U,	// NOR
    670U,	// NOREORDER
    536871597U,	// OR
    537920177U,	// ORi
    694U,	// REORDER
    603980254U,	// RET
    536871619U,	// ROTR
    576717513U,	// ROTRV
    538968784U,	// ROUND_LD
    538968784U,	// ROUND_LS
    538968793U,	// ROUND_W_D32
    538968804U,	// ROUND_W_S32
    545260271U,	// SB
    545260275U,	// SDC1
    538968825U,	// SDIV
    538968837U,	// SEB
    538968842U,	// SEH
    545260303U,	// SH
    536871699U,	// SLL
    576717592U,	// SLLV
    536871710U,	// SLT
    536871715U,	// SLTi
    536871721U,	// SLTiu
    536871728U,	// SLTu
    536871734U,	// SRA
    576717627U,	// SRAV
    536871745U,	// SRL
    576717638U,	// SRLV
    536871756U,	// SUB
    536871761U,	// SUBu
    545260375U,	// SW
    545260379U,	// SWC1
    865U,	// Select_CC
    885U,	// Select_CC_D32
    909U,	// Select_CC_S32
    933U,	// Select_FCC
    950U,	// Select_FCC_D32
    975U,	// Select_FCC_S32
    538969064U,	// TRUNC_LD
    538969064U,	// TRUNC_LS
    538969073U,	// TRUNC_W_D32
    538969084U,	// TRUNC_W_S32
    538969095U,	// UDIV
    538969108U,	// WSBW
    536871962U,	// XOR
    537920543U,	// XORi
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000add\t\000addi\t\000addiu\t\000addu\t\000!ADJCALLSTACKDOWN "
    "\000!ADJCALLSTACKUP \000and\t\000andi\t\000.set\tat\000bc1f \000bc1fl \000"
    "bc1t \000bc1tl \000beq\t\000bgez\t\000bgezal\t\000bgtz\t\000blez\t\000b"
    "ltz\t\000bltzal\t\000bne\t\000ceil.l \000ceil.w.d \000ceil.w.s \000cfc1"
    " \000clo\t\000clz\t\000.cpload\t\000.cprestore\t\000ctc1 \000cvt.d.l \000"
    "cvt.d.s \000cvt.d.w \000cvt.l \000cvt.s.d \000cvt.s.l \000cvt.s.w \000c"
    "vt.w.d \000cvt.w.s \000abs.d \000abs.s \000add.d \000add.s \000c.\000di"
    "v.d \000div.s \000floor.l \000floor.w.d \000floor.w.s \000mov.d \000mov"
    ".s \000mul.d \000mul.s \000neg.d \000neg.s \000sqrt.d \000sqrt.s \000su"
    "b.d \000sub.s \000j\t\000jal\t\000jalr\t\000jr\t\000lb\t\000lbu\t\000ld"
    "c1 \000lh\t\000lhu\t\000lui\t\000lw\t\000lwc1 \000.set\tmacro\000madd\t"
    "\000maddu\t\000mfc1 \000mfhi\t\000mflo\t\000# MOVCCRToCCR\000movn\t\000"
    "movz\t\000msub\t\000msubu\t\000mtc1 \000mthi\t\000mtlo\t\000mul\t\000mu"
    "lt\t\000multu\t\000.set\tnoat\000.set\tnomacro\000nop\000nor\t\000.set\t"
    "noreorder\000or\t\000ori\t\000.set\treorder\000rotr\t\000rotrv\t\000rou"
    "nd.l \000round.w.d \000round.w.s \000sb\t\000sdc1 \000div\t$zero, \000s"
    "eb\t\000seh\t\000sh\t\000sll\t\000sllv\t\000slt\t\000slti\t\000sltiu\t\000"
    "sltu\t\000sra\t\000srav\t\000srl\t\000srlv\t\000sub\t\000subu\t\000sw\t"
    "\000swc1 \000# MipsSelect_CC_i32\000# MipsSelect_CC_D32_f32\000# MipsSe"
    "lect_CC_S32_f32\000# MipsSelect_FCC\000# MipsSelect_FCC_D32_f32\000# Mi"
    "psSelect_FCC_S32_f32\000trunc.l \000trunc.w.d \000trunc.w.s \000divu\t$"
    "zero, \000wsbw\t\000xor\t\000xori\t\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 2047)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ATMACRO, MACRO, MOVCCRToCCR, NOAT, NOMACRO, NOP, NOREORDER,...
    return;
    break;
  case 1:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BC1F, BC1FL, BC1T, BC1TL, BEQ, BGEZ...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CPRESTORE
    printUnsignedImm(MI, 0, O); 
    break;
  case 3:
    // CTC1, MTC1
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // FCMP_D32, FCMP_S32
    printFCCOperand(MI, 2, O); 
    break;
  }


  // Fragment 1 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BC1F, BC1FL, BC1T, BC1TL, CPLOAD, J,...
    return;
    break;
  case 2:
    // CPRESTORE
    O << "\n"; 
    return;
    break;
  case 3:
    // FCMP_D32
    O << ".d "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 4:
    // FCMP_S32
    O << ".s "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 23) & 7) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // LB, LBu, LDC1, LH, LHu, LW, LWC1, SB, SDC1, SH, SW, SWC1
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 2:
    // LEA_ADDiu
    printMemOperand(MI, 1, O, "stackloc"); 
    return;
    break;
  case 3:
    // LUi
    printUnsignedImm(MI, 1, O); 
    return;
    break;
  case 4:
    // MOVN, MOVZ, ROTRV, SLLV, SRAV, SRLV
    printOperand(MI, 2, O); 
    O << ", "; 
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 21) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADDi, ADDiu, ADDu, AND, ANDi, BEQ, BNE, FADD_D32, FADD_S32, FDIV_...
    O << ", "; 
    break;
  case 1:
    // BGEZ, BGEZAL, BGTZ, BLEZ, BLTZ, BLTZAL, CEIL_LD, CEIL_LS, CEIL_W_D32, ...
    return;
    break;
  case 2:
    // MOVN, MOVZ
    printOperand(MI, 3, O); 
    return;
    break;
  case 3:
    // ROTRV, SLLV, SRAV, SRLV
    printOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 20) & 1) {
    // ANDi, ORi, XORi
    printUnsignedImm(MI, 2, O); 
    return;
  } else {
    // ADD, ADDi, ADDiu, ADDu, AND, BEQ, BNE, FADD_D32, FADD_S32, FDIV_D32, F...
    printOperand(MI, 2, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MipsAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 84 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 2, 4, 6, 8, 11, 14, 17, 20, 23, 26, 30, 34, 38, 
    42, 46, 50, 54, 58, 62, 66, 11, 70, 14, 73, 17, 76, 20, 
    79, 23, 82, 26, 85, 30, 89, 34, 93, 38, 97, 42, 101, 46, 
    105, 50, 109, 54, 113, 58, 117, 62, 121, 66, 125, 129, 132, 135, 
    138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 
    180, 182, 184, 187, 190, 193, 196, 199, 202, 205, 208, 210, 212, 0
  };

  const char *AsmStrs =
    "4\0005\0006\0007\000AT\000F0\000F2\000F4\000F6\000F8\000F10\000F12\000F"
    "14\000F16\000F18\000F20\000F22\000F24\000F26\000F28\000F30\000F1\000F3\000"
    "F5\000F7\000F9\000F11\000F13\000F15\000F17\000F19\000F21\000F23\000F25\000"
    "F27\000F29\000F31\00031\000FP\000GP\000hi\00026\00027\000lo\000RA\00016"
    "\00017\00018\00019\00020\00021\00022\00023\000SP\0008\0009\00010\00011\000"
    "12\00013\00014\00015\00024\00025\0002\0003\000ZERO\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MipsAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 156 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 155, 160, 166, 171, 188, 203, 207, 212, 220, 225, 231, 236, 242, 
    246, 251, 258, 263, 268, 273, 280, 284, 292, 300, 311, 322, 327, 331, 
    335, 342, 352, 357, 366, 375, 384, 391, 398, 407, 416, 425, 434, 443, 
    452, 461, 470, 479, 488, 497, 506, 515, 524, 533, 545, 557, 566, 575, 
    584, 593, 602, 611, 621, 631, 640, 649, 651, 655, 660, 663, 666, 670, 
    675, 685, 688, 692, 696, 699, 704, 710, 715, 721, 726, 731, 736, 748, 
    753, 758, 763, 769, 774, 779, 784, 788, 793, 799, 804, 812, 816, 820, 
    830, 833, 837, 845, 849, 854, 860, 869, 878, 890, 902, 905, 910, 915, 
    919, 923, 926, 930, 935, 939, 944, 950, 955, 959, 964, 968, 973, 977, 
    982, 985, 990, 1000, 1014, 1028, 1039, 1054, 1069, 1078, 1087, 1099, 1111, 1116, 
    1121, 1125, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADD\000ADDi\000ADDiu"
    "\000ADDu\000ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000AND\000ANDi\000ATMACR"
    "O\000BC1F\000BC1FL\000BC1T\000BC1TL\000BEQ\000BGEZ\000BGEZAL\000BGTZ\000"
    "BLEZ\000BLTZ\000BLTZAL\000BNE\000CEIL_LD\000CEIL_LS\000CEIL_W_D32\000CE"
    "IL_W_S32\000CFC1\000CLO\000CLZ\000CPLOAD\000CPRESTORE\000CTC1\000CVTD_L"
    "32\000CVTD_S32\000CVTD_W32\000CVTL_D\000CVTL_S\000CVTS_D32\000CVTS_L32\000"
    "CVTS_W32\000CVTW_D32\000CVTW_S32\000FABS_D32\000FABS_S32\000FADD_D32\000"
    "FADD_S32\000FCMP_D32\000FCMP_S32\000FDIV_D32\000FDIV_S32\000FLOOR_LD\000"
    "FLOOR_LS\000FLOOR_W_D32\000FLOOR_W_S32\000FMOV_D32\000FMOV_S32\000FMUL_"
    "D32\000FMUL_S32\000FNEG_D32\000FNEG_S32\000FSQRT_D32\000FSQRT_S32\000FS"
    "UB_D32\000FSUB_S32\000J\000JAL\000JALR\000JR\000LB\000LBu\000LDC1\000LE"
    "A_ADDiu\000LH\000LHu\000LUi\000LW\000LWC1\000MACRO\000MADD\000MADDU\000"
    "MFC1\000MFHI\000MFLO\000MOVCCRToCCR\000MOVN\000MOVZ\000MSUB\000MSUBU\000"
    "MTC1\000MTHI\000MTLO\000MUL\000MULT\000MULTu\000NOAT\000NOMACRO\000NOP\000"
    "NOR\000NOREORDER\000OR\000ORi\000REORDER\000RET\000ROTR\000ROTRV\000ROU"
    "ND_LD\000ROUND_LS\000ROUND_W_D32\000ROUND_W_S32\000SB\000SDC1\000SDIV\000"
    "SEB\000SEH\000SH\000SLL\000SLLV\000SLT\000SLTi\000SLTiu\000SLTu\000SRA\000"
    "SRAV\000SRL\000SRLV\000SUB\000SUBu\000SW\000SWC1\000Select_CC\000Select"
    "_CC_D32\000Select_CC_S32\000Select_FCC\000Select_FCC_D32\000Select_FCC_"
    "S32\000TRUNC_LD\000TRUNC_LS\000TRUNC_W_D32\000TRUNC_W_S32\000UDIV\000WS"
    "BW\000XOR\000XORi\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_AFGR64,
    RC_CCR,
    RC_CPURegs,
    RC_FGR32,
    RC_HILO
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_AFGR64:
    switch (Reg) {
    default: break;
    case Mips::D0:
    case Mips::D1:
    case Mips::D6:
    case Mips::D7:
    case Mips::D2:
    case Mips::D3:
    case Mips::D4:
    case Mips::D5:
    case Mips::D8:
    case Mips::D9:
    case Mips::D10:
    case Mips::D11:
    case Mips::D12:
    case Mips::D13:
    case Mips::D14:
    case Mips::D15:
      return true;
    }
    break;
  case RC_CCR:
    if (Reg == Mips::FCR31)
      return true;
    break;
  case RC_CPURegs:
    switch (Reg) {
    default: break;
    case Mips::V0:
    case Mips::V1:
    case Mips::A0:
    case Mips::A1:
    case Mips::A2:
    case Mips::A3:
    case Mips::T0:
    case Mips::T1:
    case Mips::T2:
    case Mips::T3:
    case Mips::T4:
    case Mips::T5:
    case Mips::T6:
    case Mips::T7:
    case Mips::T8:
    case Mips::T9:
    case Mips::S0:
    case Mips::S1:
    case Mips::S2:
    case Mips::S3:
    case Mips::S4:
    case Mips::S5:
    case Mips::S6:
    case Mips::S7:
    case Mips::ZERO:
    case Mips::AT:
    case Mips::K0:
    case Mips::K1:
    case Mips::GP:
    case Mips::SP:
    case Mips::FP:
    case Mips::RA:
      return true;
    }
    break;
  case RC_FGR32:
    switch (Reg) {
    default: break;
    case Mips::F0:
    case Mips::F1:
    case Mips::F2:
    case Mips::F3:
    case Mips::F12:
    case Mips::F13:
    case Mips::F14:
    case Mips::F15:
    case Mips::F4:
    case Mips::F5:
    case Mips::F6:
    case Mips::F7:
    case Mips::F8:
    case Mips::F9:
    case Mips::F10:
    case Mips::F11:
    case Mips::F16:
    case Mips::F17:
    case Mips::F18:
    case Mips::F19:
    case Mips::F20:
    case Mips::F21:
    case Mips::F22:
    case Mips::F23:
    case Mips::F24:
    case Mips::F25:
    case Mips::F26:
    case Mips::F27:
    case Mips::F28:
    case Mips::F29:
    case Mips::F30:
    case Mips::F31:
      return true;
    }
    break;
  case RC_HILO:
    switch (Reg) {
    default: break;
    case Mips::HI:
    case Mips::LO:
      return true;
    }
    break;
  }

  return false;
}

bool MipsAsmPrinter::printAliasInstr(const MachineInstr *MI, raw_ostream &OS) {
  return true;
}

#endif // PRINT_ALIAS_INSTR
