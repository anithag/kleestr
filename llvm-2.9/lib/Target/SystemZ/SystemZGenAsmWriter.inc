//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void SystemZAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    268435467U,	// ADC32ri
    268959761U,	// ADC32rr
    268435478U,	// ADC64ri32
    268959773U,	// ADC64rr
    268435491U,	// ADD32ri
    269484072U,	// ADD32ri16
    270008365U,	// ADD32rm
    270008368U,	// ADD32rmy
    268959796U,	// ADD32rr
    269484088U,	// ADD64ri16
    268435518U,	// ADD64ri32
    270008388U,	// ADD64rm
    268959816U,	// ADD64rr
    268959821U,	// ADDE32rr
    268959827U,	// ADDE64rr
    90U,	// ADJCALLSTACKDOWN
    108U,	// ADJCALLSTACKUP
    270532732U,	// AND32ri
    271057026U,	// AND32rilh16
    271057032U,	// AND32rill16
    270008462U,	// AND32rm
    270008465U,	// AND32rmy
    268959893U,	// AND32rr
    271057049U,	// AND64rihh16
    270532767U,	// AND64rihi32
    271057061U,	// AND64rihl16
    271057026U,	// AND64rilh16
    271057032U,	// AND64rill16
    270532732U,	// AND64rilo32
    270008491U,	// AND64rm
    268959919U,	// AND64rr
    536871092U,	// BSWAP32mr
    271581370U,	// BSWAP32rm
    272105663U,	// BSWAP32rr
    536871109U,	// BSWAP64mr
    271581388U,	// BSWAP64rm
    272105682U,	// BSWAP64rr
    805306585U,	// CALLi
    285212902U,	// CALLr
    272630002U,	// CMP32ri
    271581431U,	// CMP32rm
    271581434U,	// CMP32rmy
    272105726U,	// CMP32rr
    272630018U,	// CMP64ri32
    271581448U,	// CMP64rm
    272105740U,	// CMP64rr
    271581457U,	// CMPSX64rm32
    272105750U,	// CMPSX64rr32
    272105756U,	// FABS32rr
    272105763U,	// FABS64rr
    270008618U,	// FADD32rm
    268960047U,	// FADD32rr
    270008629U,	// FADD64rm
    268960058U,	// FADD64rr
    272105792U,	// FBCONVF64
    272105798U,	// FBCONVG64
    271581516U,	// FCMP32rm
    272105809U,	// FCMP32rr
    271581527U,	// FCMP64rm
    272105820U,	// FCMP64rr
    272105826U,	// FCONVFP32
    272105833U,	// FCONVFP32r64
    272105840U,	// FCONVFP64
    272105847U,	// FCONVFP64r32
    301990270U,	// FCONVGR32
    301990277U,	// FCONVGR32r64
    301990284U,	// FCONVGR64
    301990291U,	// FCONVGR64r32
    269091226U,	// FCOPYSIGN32
    269091226U,	// FCOPYSIGN64
    270008737U,	// FDIV32rm
    268960166U,	// FDIV32rr
    270008748U,	// FDIV64rm
    268960177U,	// FDIV64rr
    271581623U,	// FEXT32m64
    272105917U,	// FEXT32r64
    272105924U,	// FLOGR64
    273154507U,	// FMADD32rm
    273678801U,	// FMADD32rr
    273154520U,	// FMADD64rm
    273678814U,	// FMADD64rr
    536871397U,	// FMOV32mr
    536871402U,	// FMOV32mry
    271581680U,	// FMOV32rm
    271581684U,	// FMOV32rmy
    272105977U,	// FMOV32rr
    536871422U,	// FMOV64mr
    536871427U,	// FMOV64mry
    271581705U,	// FMOV64rm
    271581709U,	// FMOV64rmy
    272106002U,	// FMOV64rr
    273154583U,	// FMSUB32rm
    273678877U,	// FMSUB32rr
    273154596U,	// FMSUB64rm
    273678890U,	// FMSUB64rr
    270008881U,	// FMUL32rm
    268960311U,	// FMUL32rr
    270008894U,	// FMUL64rm
    268960323U,	// FMUL64rr
    272106057U,	// FNABS32rr
    272106064U,	// FNABS64rr
    272106071U,	// FNEG32rr
    272106078U,	// FNEG64rr
    272106085U,	// FROUND64r32
    271581804U,	// FSQRT32rm
    272106098U,	// FSQRT32rr
    271581817U,	// FSQRT64rm
    272106111U,	// FSQRT64rr
    270008966U,	// FSUB32rm
    268960395U,	// FSUB32rr
    270008977U,	// FSUB64rm
    268960406U,	// FSUB64rr
    285213340U,	// JE
    285213344U,	// JH
    285213348U,	// JHE
    285213353U,	// JL
    285213357U,	// JLE
    285213362U,	// JLH
    285213367U,	// JMP
    285213370U,	// JMPr
    285213374U,	// JNE
    285213379U,	// JNH
    285213384U,	// JNHE
    285213390U,	// JNL
    285213395U,	// JNLE
    285213401U,	// JNLH
    285213407U,	// JNO
    285213412U,	// JO
    271581928U,	// LA64r
    272106221U,	// LA64rm
    285213427U,	// LD_Fp032
    285213433U,	// LD_Fp064
    1124074239U,	// MOV128mr
    1342178070U,	// MOV128r0_even
    1683489564U,	// MOV128rm
    1617167154U,	// MOV128rr
    1962935113U,	// MOV16mi
    536871760U,	// MOV32m16r
    536871765U,	// MOV32m16ry
    536871771U,	// MOV32m8r
    536871776U,	// MOV32m8ry
    1979712358U,	// MOV32mi16
    536871788U,	// MOV32mr
    2147484528U,	// MOV32mrm
    536871798U,	// MOV32mry
    275252091U,	// MOV32ri16
    271582080U,	// MOV32rm
    272302979U,	// MOV32rmm
    271582088U,	// MOV32rmy
    272106380U,	// MOV32rr
    1191183248U,	// MOV64Pmr
    1207960486U,	// MOV64Pmry
    1342178171U,	// MOV64Pr0_even
    1685062589U,	// MOV64Prm
    1685586898U,	// MOV64Prmy
    536871760U,	// MOV64m16r
    536871765U,	// MOV64m16ry
    536871788U,	// MOV64m32r
    536871798U,	// MOV64m32ry
    536871771U,	// MOV64m8r
    536871776U,	// MOV64m8ry
    1979712488U,	// MOV64mi16
    536871919U,	// MOV64mr
    2147484660U,	// MOV64mrm
    275251990U,	// MOV64ri16
    272630778U,	// MOV64ri32
    276825088U,	// MOV64rihh16
    277349383U,	// MOV64rihi32
    276825102U,	// MOV64rihl16
    276825109U,	// MOV64rilh16
    276825116U,	// MOV64rill16
    277349411U,	// MOV64rilo32
    271582250U,	// MOV64rm
    272303150U,	// MOV64rmm
    272106547U,	// MOV64rr
    1617298488U,	// MOV64rrP
    2030044238U,	// MOV8mi
    2030044243U,	// MOV8miy
    271582297U,	// MOVSX32rm16
    271582301U,	// MOVSX32rm16y
    271582306U,	// MOVSX32rm8
    272106598U,	// MOVSX32rr16
    272106603U,	// MOVSX32rr8
    271582320U,	// MOVSX64rm16
    271582325U,	// MOVSX64rm32
    271582330U,	// MOVSX64rm8
    272106623U,	// MOVSX64rr16
    272106629U,	// MOVSX64rr32
    272106635U,	// MOVSX64rr8
    271582353U,	// MOVZX32rm16
    271582358U,	// MOVZX32rm8
    271582363U,	// MOVZX64rm16
    271582369U,	// MOVZX64rm32
    271582375U,	// MOVZX64rm8
    272106669U,	// MOVZX64rr32
    268436660U,	// MUL32ri
    269485242U,	// MUL32ri16
    270009535U,	// MUL32rm
    270009539U,	// MUL32rmy
    268960968U,	// MUL32rr
    269485261U,	// MUL64ri16
    268436691U,	// MUL64ri32
    270009562U,	// MUL64rm
    268960991U,	// MUL64rr
    268960997U,	// MUL64rrP
    268961001U,	// MULSX64rr32
    272106736U,	// NEG32rr
    272106741U,	// NEG64rr
    272106747U,	// NEG64rr32
    1282U,	// NOP
    270533898U,	// OR32ri
    270533904U,	// OR32ri16
    270533910U,	// OR32ri16h
    270009628U,	// OR32rm
    270009631U,	// OR32rmy
    268961059U,	// OR32rr
    271058215U,	// OR64rihh16
    270533933U,	// OR64rihi32
    271058227U,	// OR64rihl16
    271058198U,	// OR64rilh16
    271058192U,	// OR64rill16
    270533898U,	// OR64rilo32
    270009657U,	// OR64rm
    268961085U,	// OR64rr
    1346U,	// RET
    272303434U,	// ROTL32rri
    272303439U,	// ROTL64rri
    268436821U,	// SBC32ri
    268961116U,	// SBC32rr
    268436833U,	// SBC64ri32
    268961128U,	// SBC64rr
    270009710U,	// SDIVREM32m
    268961140U,	// SDIVREM32r
    270009723U,	// SDIVREM64m
    268961152U,	// SDIVREM64r
    2415920518U,	// SHL32rri
    272303499U,	// SHL64rri
    2415920529U,	// SRA32rri
    272303510U,	// SRA64rri
    2415920540U,	// SRL32rri
    272303521U,	// SRL64rri
    270009767U,	// SUB32rm
    270009770U,	// SUB32rmy
    268961198U,	// SUB32rr
    270009778U,	// SUB64rm
    268961206U,	// SUB64rr
    268961211U,	// SUBE32rr
    268961217U,	// SUBE64rr
    1480U,	// Select32
    1498U,	// Select64
    1516U,	// SelectF32
    1535U,	// SelectF64
    272107026U,	// UCMP32ri
    271582744U,	// UCMP32rm
    271582748U,	// UCMP32rmy
    272107041U,	// UCMP32rr
    272107046U,	// UCMP64ri32
    271582765U,	// UCMP64rm
    272107058U,	// UCMP64rr
    271582776U,	// UCMPZX64rm32
    272107070U,	// UCMPZX64rr32
    270009925U,	// UDIVREM32m
    268961353U,	// UDIVREM32r
    270009934U,	// UDIVREM64m
    268961363U,	// UDIVREM64r
    268961369U,	// UMUL128rrP
    268961375U,	// UMUL64rrP
    268961380U,	// XOR32ri
    270009962U,	// XOR32rm
    270009965U,	// XOR32rmy
    268961393U,	// XOR32rr
    270009973U,	// XOR64rm
    268961401U,	// XOR64rr
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000alfi\t\000alr\t\000algfi\t\000algr\t\000afi\t\000ahi\t\000"
    "a\t\000ay\t\000ar\t\000aghi\t\000agfi\t\000ag\t\000agr\t\000alcr\t\000a"
    "lcgr\t\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000nilf\t\000nilh\t\000n"
    "ill\t\000n\t\000ny\t\000nr\t\000nihh\t\000nihf\t\000nihl\t\000ng\t\000n"
    "gr\t\000strv\t\000lrv\t\000lrvr\t\000strvg\t\000lrvg\t\000lrvgr\t\000br"
    "asl\t%r14, \000basr\t%r14, \000cfi\t\000c\t\000cy\t\000cr\t\000cgfi\t\000"
    "cg\t\000cgr\t\000cgf\t\000cgfr\t\000lpebr\t\000lpdbr\t\000aeb\t\000aebr"
    "\t\000adb\t\000adbr\t\000ldgr\t\000lgdr\t\000ceb\t\000cebr\t\000cdb\t\000"
    "cdbr\t\000cefbr\t\000cegbr\t\000cdgbr\t\000cdfbr\t\000cfebr\t\000cfdbr\t"
    "\000cgdbr\t\000cgebr\t\000cpsdr\t\000deb\t\000debr\t\000ddb\t\000ddbr\t"
    "\000ldeb\t\000ldebr\t\000flogr\t\000maeb\t\000maebr\t\000madb\t\000madb"
    "r\t\000ste\t\000stey\t\000le\t\000ley\t\000ler\t\000std\t\000stdy\t\000"
    "ld\t\000ldy\t\000ldr\t\000mseb\t\000msebr\t\000msdb\t\000msdbr\t\000mee"
    "b\t\000meebr\t\000mdb\t\000mdbr\t\000lnebr\t\000lndbr\t\000lcebr\t\000l"
    "cdbr\t\000ledbr\t\000sqeb\t\000sqebr\t\000sqdb\t\000sqdbr\t\000seb\t\000"
    "sebr\t\000sdb\t\000sdbr\t\000je\t\000jh\t\000jhe\t\000jl\t\000jle\t\000"
    "jlh\t\000j\t\000br\t\000jne\t\000jnh\t\000jnhe\t\000jnl\t\000jnle\t\000"
    "jnlh\t\000jno\t\000jo\t\000lay\t\000larl\t\000lzer\t\000lzdr\t\000# MOV"
    "128 PSEUDO!\n\tstg\t\000lghi\t\000# MOV128 PSEUDO!\n\tlg\t\000# MOV128 "
    "PSEUDO!\n\tlgr\t\000mvhhi\t\000sth\t\000sthy\t\000stc\t\000stcy\t\000mv"
    "hi\t\000st\t\000stmy\t\000sty\t\000lhi\t\000l\t\000lmy\t\000ly\t\000lr\t"
    "\000# MOV64P PSEUDO!\n\tst\t\000# MOV64P PSEUDO!\n\tsty\t\000# MOV64P P"
    "SEUDO!\n\tl\t\000# MOV64P PSEUDO!\n\tly\t\000mvghi\t\000stg\t\000stmg\t"
    "\000lgfi\t\000llihh\t\000llihf\t\000llihl\t\000llilh\t\000llill\t\000ll"
    "ilf\t\000lg\t\000lmg\t\000lgr\t\000# MOV64P PSEUDO!\n\tlr\t\000mvi\t\000"
    "mviy\t\000lh\t\000lhy\t\000lb\t\000lhr\t\000lbr\t\000lgh\t\000lgf\t\000"
    "lgb\t\000lghr\t\000lgfr\t\000lgbr\t\000llh\t\000llc\t\000llgh\t\000llgf"
    "\t\000llgc\t\000llgfr\t\000msfi\t\000mhi\t\000ms\t\000msy\t\000msr\t\000"
    "mghi\t\000msgfi\t\000msg\t\000msgr\t\000mr\t\000msgfr\t\000lcr\t\000lcg"
    "r\t\000lcgfr\t\000# no-op\000oilf\t\000oill\t\000oilh\t\000o\t\000oy\t\000"
    "or\t\000oihh\t\000oihf\t\000oihl\t\000og\t\000ogr\t\000br\t%r14\000rll\t"
    "\000rllg\t\000sllfi\t\000slr\t\000slgfi\t\000slgr\t\000dsgf\t\000dsgfr\t"
    "\000dsg\t\000dsgr\t\000sll\t\000sllg\t\000sra\t\000srag\t\000srl\t\000s"
    "rlg\t\000s\t\000sy\t\000sr\t\000sg\t\000sgr\t\000slbr\t\000slbgr\t\000#"
    " Select32 PSEUDO\000# Select64 PSEUDO\000# SelectF32 PSEUDO\000# Select"
    "F64 PSEUDO\000clfi\t\000cl\t\000cly\t\000clr\t\000clgfi\t\000clg\t\000c"
    "lgr\t\000clgf\t\000clgfr\t\000dl\t\000dlr\t\000dlg\t\000dlgr\t\000mlgr\t"
    "\000mlr\t\000xilf\t\000x\t\000xy\t\000xr\t\000xg\t\000xgr\t\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 2047)-1;


  // Fragment 0 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, Select32, Selec...
    return;
    break;
  case 1:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // BSWAP32mr, BSWAP64mr, FMOV32mr, FMOV32mry, FMOV64mr, FMOV64mry, MOV32m...
    printOperand(MI, 3, O); 
    O << ", "; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // CALLi
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // MOV128mr, MOV64Pmr, MOV64Pmry
    printOperand(MI, 3, O, "subreg_odd"); 
    O << ", "; 
    printRRIAddrOperand(MI, 0, O); 
    break;
  case 5:
    // MOV128r0_even, MOV64Pr0_even
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 0"; 
    return;
    break;
  case 6:
    // MOV128rm, MOV128rr, MOV64Prm, MOV64Prmy, MOV64rrP
    printOperand(MI, 0, O, "subreg_odd"); 
    break;
  case 7:
    // MOV16mi, MOV32mi16, MOV64mi16, MOV8mi, MOV8miy
    printRIAddrOperand(MI, 0, O); 
    O << ", "; 
    break;
  case 8:
    // MOV32mrm, MOV64mrm
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 3, O); 
    O << ", "; 
    printRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // SHL32rri, SRA32rri, SRL32rri
    printOperand(MI, 1, O); 
    O << ", "; 
    printRIAddrOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 24) & 15) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    O << ", "; 
    break;
  case 1:
    // CALLr, JE, JH, JHE, JL, JLE, JLH, JMP, JMPr, JNE, JNH, JNHE, JNL, JNLE...
    return;
    break;
  case 2:
    // FCONVGR32, FCONVGR32r64, FCONVGR64, FCONVGR64r32
    O << ", 5, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // MOV128mr
    O << "\n\tstg\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // MOV128rm, MOV64Prm, MOV64Prmy
    O << ",  "; 
    printRRIAddrOperand(MI, 1, O); 
    break;
  case 5:
    // MOV16mi
    printS16ImmOperand(MI, 2, O); 
    return;
    break;
  case 6:
    // MOV32mi16, MOV64mi16
    printS32ImmOperand(MI, 2, O); 
    return;
    break;
  case 7:
    // MOV64Pmr
    O << "\n\tst\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 8:
    // MOV64Pmry
    O << "\n\tsty\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // MOV8mi, MOV8miy
    printOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 5 bits for 18 unique commands.
  switch ((Bits >> 19) & 31) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC64ri32, ADD32ri, ADD64ri32, MUL32ri, MUL64ri32, SBC32ri, S...
    printS32ImmOperand(MI, 2, O); 
    return;
    break;
  case 1:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32rr, AND64...
    printOperand(MI, 2, O); 
    break;
  case 2:
    // ADD32ri16, ADD64ri16, MUL32ri16, MUL64ri16
    printS16ImmOperand(MI, 2, O); 
    return;
    break;
  case 3:
    // ADD32rm, ADD32rmy, ADD64rm, AND32rm, AND32rmy, AND64rm, FADD32rm, FADD...
    printRRIAddrOperand(MI, 2, O); 
    return;
    break;
  case 4:
    // AND32ri, AND64rihi32, AND64rilo32, OR32ri, OR32ri16, OR32ri16h, OR64ri...
    printU32ImmOperand(MI, 2, O); 
    return;
    break;
  case 5:
    // AND32rilh16, AND32rill16, AND64rihh16, AND64rihl16, AND64rilh16, AND64...
    printU16ImmOperand(MI, 2, O); 
    return;
    break;
  case 6:
    // BSWAP32rm, BSWAP64rm, CMP32rm, CMP32rmy, CMP64rm, CMPSX64rm32, FCMP32r...
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 7:
    // BSWAP32rr, BSWAP64rr, CMP32rr, CMP64rr, CMPSX64rr32, FABS32rr, FABS64r...
    printOperand(MI, 1, O); 
    break;
  case 8:
    // CMP32ri, CMP64ri32, MOV64ri32
    printS32ImmOperand(MI, 1, O); 
    return;
    break;
  case 9:
    // FMADD32rm, FMADD64rm, FMSUB32rm, FMSUB64rm
    printOperand(MI, 5, O); 
    O << ", "; 
    printRRIAddrOperand(MI, 2, O); 
    return;
    break;
  case 10:
    // FMADD32rr, FMADD64rr, FMSUB32rr, FMSUB64rr
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 11:
    // MOV128rm
    O << "\n\tlg\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 12:
    // MOV128rr, MOV64rrP
    printOperand(MI, 1, O, "subreg_odd"); 
    break;
  case 13:
    // MOV32ri16, MOV64ri16
    printS16ImmOperand(MI, 1, O); 
    return;
    break;
  case 14:
    // MOV64Prm
    O << "\n\tl\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 15:
    // MOV64Prmy
    O << "\n\tly\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 16:
    // MOV64rihh16, MOV64rihl16, MOV64rilh16, MOV64rill16
    printU16ImmOperand(MI, 1, O); 
    return;
    break;
  case 17:
    // MOV64rihi32, MOV64rilo32
    printU32ImmOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 17) & 3) {
  default:   // unreachable.
  case 0:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32rr, AND64...
    return;
    break;
  case 1:
    // FCOPYSIGN32, FCOPYSIGN64, MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SH...
    O << ", "; 
    break;
  case 2:
    // MOV128rr
    O << "\n\tlgr\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, O, "subreg_even"); 
    return;
    break;
  case 3:
    // MOV64rrP
    O << "\n\tlr\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, O, "subreg_even"); 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 16) & 1) {
    // MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SHL64rri, SRA64rri, SRL64rri
    printRIAddrOperand(MI, 2, O); 
    return;
  } else {
    // FCOPYSIGN32, FCOPYSIGN64
    printOperand(MI, 1, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *SystemZAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 82 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 6, 9, 9, 12, 12, 15, 15, 18, 18, 21, 21, 
    24, 24, 27, 27, 30, 30, 33, 33, 37, 37, 41, 41, 45, 45, 
    49, 49, 53, 53, 57, 61, 61, 61, 61, 64, 64, 67, 67, 67, 
    67, 70, 70, 73, 73, 73, 73, 76, 76, 79, 79, 79, 79, 82, 
    82, 85, 85, 85, 85, 88, 88, 91, 91, 91, 91, 95, 95, 99, 
    99, 99, 99, 103, 103, 107, 107, 107, 107, 111, 111, 0
  };

  const char *AsmStrs =
    "f0\000f0\000f1\000f2\000f3\000f4\000f5\000f6\000f7\000f8\000f9\000f10\000"
    "f11\000f12\000f13\000f14\000f15\000psw\000r0\000r1\000r2\000r3\000r4\000"
    "r5\000r6\000r7\000r8\000r9\000r10\000r11\000r12\000r13\000r14\000r15\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *SystemZAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 287 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 159, 167, 177, 185, 193, 203, 211, 220, 228, 238, 248, 256, 264, 
    273, 282, 299, 314, 322, 334, 346, 354, 363, 371, 383, 395, 407, 419, 
    431, 443, 451, 459, 469, 479, 489, 499, 509, 519, 525, 531, 539, 547, 
    556, 564, 574, 582, 590, 602, 614, 623, 632, 641, 650, 659, 668, 678, 
    688, 697, 706, 715, 724, 734, 747, 757, 770, 780, 793, 803, 816, 828, 
    840, 849, 858, 867, 876, 886, 896, 904, 914, 924, 934, 944, 953, 963, 
    972, 982, 991, 1000, 1010, 1019, 1029, 1038, 1048, 1058, 1068, 1078, 1087, 1096, 
    1105, 1114, 1124, 1134, 1143, 1152, 1164, 1174, 1184, 1194, 1204, 1213, 1222, 1231, 
    1240, 1243, 1246, 1250, 1253, 1257, 1261, 1265, 1270, 1274, 1278, 1283, 1287, 1292, 
    1297, 1301, 1304, 1310, 1317, 1326, 1335, 1344, 1358, 1367, 1376, 1384, 1394, 1405, 
    1414, 1424, 1434, 1442, 1451, 1460, 1470, 1478, 1487, 1496, 1504, 1513, 1523, 1537, 
    1546, 1556, 1566, 1577, 1587, 1598, 1607, 1617, 1627, 1635, 1644, 1654, 1664, 1676, 
    1688, 1700, 1712, 1724, 1736, 1744, 1753, 1761, 1770, 1777, 1785, 1797, 1810, 1821, 
    1833, 1844, 1856, 1868, 1879, 1891, 1903, 1914, 1926, 1937, 1949, 1961, 1972, 1984, 
    1992, 2002, 2010, 2019, 2027, 2037, 2047, 2055, 2063, 2072, 2084, 2092, 2100, 2110, 
    2114, 2121, 2130, 2140, 2147, 2155, 2162, 2173, 2184, 2195, 2206, 2217, 2228, 2235, 
    2242, 2246, 2256, 2266, 2274, 2282, 2292, 2300, 2311, 2322, 2333, 2344, 2353, 2362, 
    2371, 2380, 2389, 2398, 2406, 2415, 2423, 2431, 2439, 2448, 2457, 2466, 2475, 2485, 
    2495, 2504, 2513, 2523, 2532, 2543, 2552, 2561, 2574, 2587, 2598, 2609, 2620, 2631, 
    2642, 2652, 2660, 2668, 2677, 2685, 2693, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADC32ri\000ADC32rr\000"
    "ADC64ri32\000ADC64rr\000ADD32ri\000ADD32ri16\000ADD32rm\000ADD32rmy\000"
    "ADD32rr\000ADD64ri16\000ADD64ri32\000ADD64rm\000ADD64rr\000ADDE32rr\000"
    "ADDE64rr\000ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000AND32ri\000AND32rilh1"
    "6\000AND32rill16\000AND32rm\000AND32rmy\000AND32rr\000AND64rihh16\000AN"
    "D64rihi32\000AND64rihl16\000AND64rilh16\000AND64rill16\000AND64rilo32\000"
    "AND64rm\000AND64rr\000BSWAP32mr\000BSWAP32rm\000BSWAP32rr\000BSWAP64mr\000"
    "BSWAP64rm\000BSWAP64rr\000CALLi\000CALLr\000CMP32ri\000CMP32rm\000CMP32"
    "rmy\000CMP32rr\000CMP64ri32\000CMP64rm\000CMP64rr\000CMPSX64rm32\000CMP"
    "SX64rr32\000FABS32rr\000FABS64rr\000FADD32rm\000FADD32rr\000FADD64rm\000"
    "FADD64rr\000FBCONVF64\000FBCONVG64\000FCMP32rm\000FCMP32rr\000FCMP64rm\000"
    "FCMP64rr\000FCONVFP32\000FCONVFP32r64\000FCONVFP64\000FCONVFP64r32\000F"
    "CONVGR32\000FCONVGR32r64\000FCONVGR64\000FCONVGR64r32\000FCOPYSIGN32\000"
    "FCOPYSIGN64\000FDIV32rm\000FDIV32rr\000FDIV64rm\000FDIV64rr\000FEXT32m6"
    "4\000FEXT32r64\000FLOGR64\000FMADD32rm\000FMADD32rr\000FMADD64rm\000FMA"
    "DD64rr\000FMOV32mr\000FMOV32mry\000FMOV32rm\000FMOV32rmy\000FMOV32rr\000"
    "FMOV64mr\000FMOV64mry\000FMOV64rm\000FMOV64rmy\000FMOV64rr\000FMSUB32rm"
    "\000FMSUB32rr\000FMSUB64rm\000FMSUB64rr\000FMUL32rm\000FMUL32rr\000FMUL"
    "64rm\000FMUL64rr\000FNABS32rr\000FNABS64rr\000FNEG32rr\000FNEG64rr\000F"
    "ROUND64r32\000FSQRT32rm\000FSQRT32rr\000FSQRT64rm\000FSQRT64rr\000FSUB3"
    "2rm\000FSUB32rr\000FSUB64rm\000FSUB64rr\000JE\000JH\000JHE\000JL\000JLE"
    "\000JLH\000JMP\000JMPr\000JNE\000JNH\000JNHE\000JNL\000JNLE\000JNLH\000"
    "JNO\000JO\000LA64r\000LA64rm\000LD_Fp032\000LD_Fp064\000MOV128mr\000MOV"
    "128r0_even\000MOV128rm\000MOV128rr\000MOV16mi\000MOV32m16r\000MOV32m16r"
    "y\000MOV32m8r\000MOV32m8ry\000MOV32mi16\000MOV32mr\000MOV32mrm\000MOV32"
    "mry\000MOV32ri16\000MOV32rm\000MOV32rmm\000MOV32rmy\000MOV32rr\000MOV64"
    "Pmr\000MOV64Pmry\000MOV64Pr0_even\000MOV64Prm\000MOV64Prmy\000MOV64m16r"
    "\000MOV64m16ry\000MOV64m32r\000MOV64m32ry\000MOV64m8r\000MOV64m8ry\000M"
    "OV64mi16\000MOV64mr\000MOV64mrm\000MOV64ri16\000MOV64ri32\000MOV64rihh1"
    "6\000MOV64rihi32\000MOV64rihl16\000MOV64rilh16\000MOV64rill16\000MOV64r"
    "ilo32\000MOV64rm\000MOV64rmm\000MOV64rr\000MOV64rrP\000MOV8mi\000MOV8mi"
    "y\000MOVSX32rm16\000MOVSX32rm16y\000MOVSX32rm8\000MOVSX32rr16\000MOVSX3"
    "2rr8\000MOVSX64rm16\000MOVSX64rm32\000MOVSX64rm8\000MOVSX64rr16\000MOVS"
    "X64rr32\000MOVSX64rr8\000MOVZX32rm16\000MOVZX32rm8\000MOVZX64rm16\000MO"
    "VZX64rm32\000MOVZX64rm8\000MOVZX64rr32\000MUL32ri\000MUL32ri16\000MUL32"
    "rm\000MUL32rmy\000MUL32rr\000MUL64ri16\000MUL64ri32\000MUL64rm\000MUL64"
    "rr\000MUL64rrP\000MULSX64rr32\000NEG32rr\000NEG64rr\000NEG64rr32\000NOP"
    "\000OR32ri\000OR32ri16\000OR32ri16h\000OR32rm\000OR32rmy\000OR32rr\000O"
    "R64rihh16\000OR64rihi32\000OR64rihl16\000OR64rilh16\000OR64rill16\000OR"
    "64rilo32\000OR64rm\000OR64rr\000RET\000ROTL32rri\000ROTL64rri\000SBC32r"
    "i\000SBC32rr\000SBC64ri32\000SBC64rr\000SDIVREM32m\000SDIVREM32r\000SDI"
    "VREM64m\000SDIVREM64r\000SHL32rri\000SHL64rri\000SRA32rri\000SRA64rri\000"
    "SRL32rri\000SRL64rri\000SUB32rm\000SUB32rmy\000SUB32rr\000SUB64rm\000SU"
    "B64rr\000SUBE32rr\000SUBE64rr\000Select32\000Select64\000SelectF32\000S"
    "electF64\000UCMP32ri\000UCMP32rm\000UCMP32rmy\000UCMP32rr\000UCMP64ri32"
    "\000UCMP64rm\000UCMP64rr\000UCMPZX64rm32\000UCMPZX64rr32\000UDIVREM32m\000"
    "UDIVREM32r\000UDIVREM64m\000UDIVREM64r\000UMUL128rrP\000UMUL64rrP\000XO"
    "R32ri\000XOR32rm\000XOR32rmy\000XOR32rr\000XOR64rm\000XOR64rr\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_ADDR32,
    RC_ADDR64,
    RC_CCR,
    RC_FP32,
    RC_FP64,
    RC_GR128,
    RC_GR32,
    RC_GR64,
    RC_GR64P
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_ADDR32:
    switch (Reg) {
    default: break;
    case SystemZ::R1W:
    case SystemZ::R2W:
    case SystemZ::R3W:
    case SystemZ::R4W:
    case SystemZ::R5W:
    case SystemZ::R6W:
    case SystemZ::R7W:
    case SystemZ::R8W:
    case SystemZ::R9W:
    case SystemZ::R10W:
    case SystemZ::R12W:
    case SystemZ::R13W:
    case SystemZ::R11W:
    case SystemZ::R14W:
    case SystemZ::R15W:
      return true;
    }
    break;
  case RC_ADDR64:
    switch (Reg) {
    default: break;
    case SystemZ::R1D:
    case SystemZ::R2D:
    case SystemZ::R3D:
    case SystemZ::R4D:
    case SystemZ::R5D:
    case SystemZ::R6D:
    case SystemZ::R7D:
    case SystemZ::R8D:
    case SystemZ::R9D:
    case SystemZ::R10D:
    case SystemZ::R12D:
    case SystemZ::R13D:
    case SystemZ::R11D:
    case SystemZ::R14D:
    case SystemZ::R15D:
      return true;
    }
    break;
  case RC_CCR:
    if (Reg == SystemZ::PSW)
      return true;
    break;
  case RC_FP32:
    switch (Reg) {
    default: break;
    case SystemZ::F0S:
    case SystemZ::F1S:
    case SystemZ::F2S:
    case SystemZ::F3S:
    case SystemZ::F4S:
    case SystemZ::F5S:
    case SystemZ::F6S:
    case SystemZ::F7S:
    case SystemZ::F8S:
    case SystemZ::F9S:
    case SystemZ::F10S:
    case SystemZ::F11S:
    case SystemZ::F12S:
    case SystemZ::F13S:
    case SystemZ::F14S:
    case SystemZ::F15S:
      return true;
    }
    break;
  case RC_FP64:
    switch (Reg) {
    default: break;
    case SystemZ::F0L:
    case SystemZ::F1L:
    case SystemZ::F2L:
    case SystemZ::F3L:
    case SystemZ::F4L:
    case SystemZ::F5L:
    case SystemZ::F6L:
    case SystemZ::F7L:
    case SystemZ::F8L:
    case SystemZ::F9L:
    case SystemZ::F10L:
    case SystemZ::F11L:
    case SystemZ::F12L:
    case SystemZ::F13L:
    case SystemZ::F14L:
    case SystemZ::F15L:
      return true;
    }
    break;
  case RC_GR128:
    switch (Reg) {
    default: break;
    case SystemZ::R0Q:
    case SystemZ::R2Q:
    case SystemZ::R4Q:
    case SystemZ::R6Q:
    case SystemZ::R8Q:
    case SystemZ::R10Q:
    case SystemZ::R12Q:
    case SystemZ::R14Q:
      return true;
    }
    break;
  case RC_GR32:
    switch (Reg) {
    default: break;
    case SystemZ::R0W:
    case SystemZ::R1W:
    case SystemZ::R2W:
    case SystemZ::R3W:
    case SystemZ::R4W:
    case SystemZ::R5W:
    case SystemZ::R6W:
    case SystemZ::R7W:
    case SystemZ::R8W:
    case SystemZ::R9W:
    case SystemZ::R10W:
    case SystemZ::R12W:
    case SystemZ::R13W:
    case SystemZ::R11W:
    case SystemZ::R14W:
    case SystemZ::R15W:
      return true;
    }
    break;
  case RC_GR64:
    switch (Reg) {
    default: break;
    case SystemZ::R0D:
    case SystemZ::R1D:
    case SystemZ::R2D:
    case SystemZ::R3D:
    case SystemZ::R4D:
    case SystemZ::R5D:
    case SystemZ::R6D:
    case SystemZ::R7D:
    case SystemZ::R8D:
    case SystemZ::R9D:
    case SystemZ::R10D:
    case SystemZ::R12D:
    case SystemZ::R13D:
    case SystemZ::R11D:
    case SystemZ::R14D:
    case SystemZ::R15D:
      return true;
    }
    break;
  case RC_GR64P:
    switch (Reg) {
    default: break;
    case SystemZ::R0P:
    case SystemZ::R2P:
    case SystemZ::R4P:
    case SystemZ::R6P:
    case SystemZ::R8P:
    case SystemZ::R10P:
    case SystemZ::R12P:
    case SystemZ::R14P:
      return true;
    }
    break;
  }

  return false;
}

bool SystemZAsmPrinter::printAliasInstr(const MachineInstr *MI, raw_ostream &OS) {
  return true;
}

#endif // PRINT_ALIAS_INSTR
