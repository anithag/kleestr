//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void BlackfinAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// ABORT
    536870930U,	// ADD
    536870930U,	// ADD16
    536887314U,	// ADD_RND20
    545259538U,	// ADDimm7
    536870930U,	// ADDpp
    545259538U,	// ADDpp_imm7
    1090519058U,	// ADJCALLSTACKDOWN
    1098907666U,	// ADJCALLSTACKUP
    570425362U,	// ALIGN16
    570425362U,	// ALIGN24
    578813970U,	// ALIGN8
    537133074U,	// AND
    587202579U,	// BITCLR
    587202587U,	// BITSET
    587202595U,	// BITTGL
    1660944427U,	// BITTST
    595591224U,	// CALLa
    603979838U,	// CALLp
    595591237U,	// CLI
    74U,	// CSYNC
    81U,	// DISALGNEXCPT
    96U,	// EMUEXCPT
    595591274U,	// EXCPT
    113U,	// IDLE
    595591287U,	// JUMPa
    612368509U,	// JUMPcc
    603979905U,	// JUMPp
    595591304U,	// LINK
    1158152210U,	// LOAD16fi
    537657362U,	// LOAD16i
    537657362U,	// LOAD16i_d16
    630226962U,	// LOAD16pi
    630505490U,	// LOAD16s32p_dec
    630521874U,	// LOAD16s32p_inc
    630538258U,	// LOAD16s32p_post
    630554642U,	// LOAD16z32p_dec
    630571026U,	// LOAD16z32p_inc
    630542354U,	// LOAD16z32p_post
    1158152210U,	// LOAD32fi
    638713874U,	// LOAD32fp_nimm7m4
    638615570U,	// LOAD32i
    638992402U,	// LOAD32i_dec
    639008786U,	// LOAD32i_inc
    639025170U,	// LOAD32i_post
    645922834U,	// LOAD32imm
    638615570U,	// LOAD32p
    630390802U,	// LOAD32p_16s
    654311442U,	// LOAD32p_16z
    663945234U,	// LOAD32p_8s
    671088658U,	// LOAD32p_8z
    638992402U,	// LOAD32p_dec
    663961618U,	// LOAD32p_imm16_8s
    663965714U,	// LOAD32p_imm16_8z
    630407186U,	// LOAD32p_imm17m2_16s
    630411282U,	// LOAD32p_imm17m2_16z
    638803986U,	// LOAD32p_imm18m4
    639008786U,	// LOAD32p_inc
    639025170U,	// LOAD32p_post
    630407186U,	// LOAD32p_uimm5m2_16s
    630411282U,	// LOAD32p_uimm5m2_16z
    638803986U,	// LOAD32p_uimm6m4
    679477266U,	// LOAD32sym
    1159200786U,	// LOAD8fi
    664059922U,	// LOAD8s32p_dec
    664076306U,	// LOAD8s32p_inc
    664109074U,	// LOAD8z32p_dec
    664125458U,	// LOAD8z32p_inc
    630603794U,	// LOADhi_dec
    630620178U,	// LOADhi_inc
    630636562U,	// LOADhp_post
    538705938U,	// LOADimm16
    538705938U,	// LOADimm7
    538968082U,	// LOADuimm16
    142U,	// MNOP
    537657362U,	// MOVE
    1669333140U,	// MOVECC_nz
    537657362U,	// MOVECC_zext
    687865874U,	// MOVENCC_z
    154U,	// MOVE_cc_ac0
    164U,	// MOVE_ccncc
    164U,	// MOVE_ncccc
    2147483773U,	// MOVEcc
    538705938U,	// MOVEsext
    539230226U,	// MOVEsext8
    538968082U,	// MOVEzext
    539492370U,	// MOVEzext8
    539983890U,	// MUL16
    696254482U,	// MUL32
    540000274U,	// MULHS16
    539983890U,	// MULhh32s
    539983890U,	// MULhh32u
    1660944558U,	// NBITTST
    704643090U,	// NEG
    188U,	// NOP
    713031698U,	// NOT
    721420306U,	// ONES
    540016658U,	// OR
    193U,	// OR_ac0_cc
    729808914U,	// POP
    595591372U,	// PUSH
    595591382U,	// RAISE
    221U,	// RTS
    1811939476U,	// SETEQdd
    1811939476U,	// SETEQpp
    1811939476U,	// SETEQri
    1811939476U,	// SETEQri_not
    1821114516U,	// SETLEdd
    1821114516U,	// SETLEpp
    1821114516U,	// SETLEri
    1821114516U,	// SETLEri_not
    1829503124U,	// SETLTdd
    1829503124U,	// SETLTpp
    1829503124U,	// SETLTri
    1829503124U,	// SETLTri_not
    1811939476U,	// SETNEdd
    1823735956U,	// SETULEdd
    1823735956U,	// SETULEpp
    1823735956U,	// SETULEri
    1823735956U,	// SETULEri_not
    1832124564U,	// SETULTdd
    1832124564U,	// SETULTpp
    1832124564U,	// SETULTri
    1832124564U,	// SETULTri_not
    767033362U,	// SLA16r
    767295506U,	// SLAr16
    541065234U,	// SLL16i
    771751954U,	// SLL16r
    780140562U,	// SLLi
    780140562U,	// SLLr
    771751954U,	// SLLr16
    541327378U,	// SRA16i
    788529170U,	// SRAi
    788529170U,	// SRAr
    541589522U,	// SRL16i
    796917778U,	// SRLi
    796917778U,	// SRLr
    226U,	// SSYNC
    595591401U,	// STI
    1342177298U,	// STORE16fi
    2961178862U,	// STORE16i_dec
    2969567470U,	// STORE16i_inc
    2977956078U,	// STORE16p_post
    1912602862U,	// STORE16pi
    1342177298U,	// STORE32fi
    1920991473U,	// STORE32fp_nimm7m4
    1912602865U,	// STORE32i
    2961178865U,	// STORE32i_dec
    2969567473U,	// STORE32i_inc
    2977956081U,	// STORE32i_post
    1912602865U,	// STORE32p
    2961178865U,	// STORE32p_dec
    1929380081U,	// STORE32p_imm18m4
    2969567473U,	// STORE32p_inc
    2977956081U,	// STORE32p_post
    1929380081U,	// STORE32p_uimm6m4
    1400897554U,	// STORE8fi
    1912602867U,	// STORE8p
    2961178867U,	// STORE8p_dec
    1929380083U,	// STORE8p_imm16
    2969567475U,	// STORE8p_inc
    541851666U,	// SUB
    541851666U,	// SUB16
    246U,	// UNLINK
    542113810U,	// XOR
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000abort;\000\000bitclr(\000bitset(\000bittgl(\000cc = bittst"
    "(\000call \000call (\000cli \000csync;\000disalignexcpt;\000emuexcpt;\000"
    "excpt \000idle;\000jump \000if \000JUMP (\000link \000mnop;\000cc = \000"
    "cc = ac0;\000cc = !cc;\000cc = !bittst(\000nop;\000ac0 |= cc;\000[--sp]"
    " = \000raise \000rts;\000ssync;\000sti \000w[\000[\000b[\000unlink;\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 255)-1;


  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ABORT, CSYNC, DISALGNEXCPT, EMUEXCPT, IDLE, MNOP, MOVE_cc_a...
    return;
    break;
  case 1:
    // ADD, ADD16, ADD_RND20, ADDimm7, ADDpp, ADDpp_imm7, ALIGN16, ALIGN24, A...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LOAD16fi, LOAD32fi, LOAD8fi, STORE16...
    PrintSpecial(MI, O, "comment"); 
    break;
  case 3:
    // BITTST, MOVECC_nz, NBITTST, SETEQdd, SETEQpp, SETEQri, SETEQri_not, SE...
    printOperand(MI, 1, O); 
    break;
  case 4:
    // MOVEcc
    printOperand(MI, 3, O); 
    O << ' '; 
    printOperand(MI, 0, O); 
    O << " = "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 5:
    // STORE16i_dec, STORE16i_inc, STORE16p_post, STORE32i_dec, STORE32i_inc,...
    printOperand(MI, 2, O); 
    break;
  }


  // Fragment 1 encoded into 6 bits for 40 unique commands.
  switch ((Bits >> 23) & 63) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADD_RND20, ADDpp, AND, LOAD16i, LOAD16i_d16, LOADimm16, LO...
    O << " = "; 
    printOperand(MI, 1, O); 
    break;
  case 1:
    // ADDimm7, ADDpp_imm7
    O << " += "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 2:
    // ADJCALLSTACKDOWN
    O << "ADJCALLSTACKDOWN "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // ADJCALLSTACKUP
    O << "ADJCALLSTACKUP "; 
    printOperand(MI, 0, O); 
    O << ' '; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 4:
    // ALIGN16, ALIGN24
    O << " = align16("; 
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 2, O); 
    O << ");"; 
    return;
    break;
  case 5:
    // ALIGN8
    O << " = align8("; 
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 2, O); 
    O << ");"; 
    return;
    break;
  case 6:
    // BITCLR, BITSET, BITTGL, BITTST, NBITTST
    O << ", "; 
    printOperand(MI, 2, O); 
    O << ");"; 
    return;
    break;
  case 7:
    // CALLa, CLI, EXCPT, JUMPa, LINK, MOVECC_nz, PUSH, RAISE, STI
    O << ';'; 
    return;
    break;
  case 8:
    // CALLp, JUMPp
    O << ");"; 
    return;
    break;
  case 9:
    // JUMPcc
    O << " jump "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 10:
    // LOAD16fi, LOAD32fi, LOAD8fi
    O << "FI "; 
    printOperand(MI, 0, O); 
    break;
  case 11:
    // LOAD16pi, LOAD16s32p_dec, LOAD16s32p_inc, LOAD16s32p_post, LOAD16z32p_...
    O << " = w["; 
    break;
  case 12:
    // LOAD32fp_nimm7m4, LOAD32i, LOAD32i_dec, LOAD32i_inc, LOAD32i_post, LOA...
    O << " = ["; 
    break;
  case 13:
    // LOAD32imm
    O << ".h = ("; 
    printOperand(MI, 1, O); 
    O << " >> 16); "; 
    printOperand(MI, 0, O); 
    O << ".l = ("; 
    printOperand(MI, 1, O); 
    O << " & 0xffff);"; 
    return;
    break;
  case 14:
    // LOAD32p_16z
    O << " = W["; 
    printOperand(MI, 1, O); 
    O << "] (z);"; 
    return;
    break;
  case 15:
    // LOAD32p_8s, LOAD32p_imm16_8s, LOAD32p_imm16_8z, LOAD8s32p_dec, LOAD8s3...
    O << " = b["; 
    break;
  case 16:
    // LOAD32p_8z
    O << " = B["; 
    printOperand(MI, 1, O); 
    O << "] (z);"; 
    return;
    break;
  case 17:
    // LOAD32sym
    O << ".h = "; 
    printOperand(MI, 1, O); 
    O << "; "; 
    printOperand(MI, 0, O); 
    O << ".l = "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 18:
    // MOVENCC_z
    O << " = cc;"; 
    return;
    break;
  case 19:
    // MUL32
    O << " *= "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 20:
    // NEG
    O << " = -"; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 21:
    // NOT
    O << " = ~"; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 22:
    // ONES
    O << " = ones "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 23:
    // POP
    O << " = [sp++];"; 
    return;
    break;
  case 24:
    // SETEQdd, SETEQpp, SETEQri, SETEQri_not, SETNEdd
    O << " == "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 25:
    // SETLEdd, SETLEpp, SETLEri, SETLEri_not, SETULEdd, SETULEpp, SETULEri, ...
    O << " <= "; 
    printOperand(MI, 2, O); 
    break;
  case 26:
    // SETLTdd, SETLTpp, SETLTri, SETLTri_not, SETULTdd, SETULTpp, SETULTri, ...
    O << " < "; 
    printOperand(MI, 2, O); 
    break;
  case 27:
    // SLA16r, SLAr16
    O << " = ashift "; 
    printOperand(MI, 1, O); 
    break;
  case 28:
    // SLL16r, SLLr16
    O << " = lshift "; 
    printOperand(MI, 1, O); 
    O << " by "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 29:
    // SLLi, SLLr
    O << " <<= "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 30:
    // SRAi, SRAr
    O << " >>>= "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 31:
    // SRLi, SRLr
    O << " >>= "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 32:
    // STORE16fi, STORE32fi
    O << "FI ["; 
    printMemoryOperand(MI, 1, O); 
    O << "] = "; 
    printOperand(MI, 0, O); 
    O << ';'; 
    return;
    break;
  case 33:
    // STORE16i_dec, STORE32i_dec, STORE32p_dec, STORE8p_dec
    O << "--] = "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 34:
    // STORE16i_inc, STORE32i_inc, STORE32p_inc, STORE8p_inc
    O << "++] = "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 35:
    // STORE16p_post, STORE32i_post, STORE32p_post
    O << " ++ "; 
    printOperand(MI, 3, O); 
    O << "] = "; 
    printOperand(MI, 1, O); 
    O << ';'; 
    return;
    break;
  case 36:
    // STORE16pi, STORE32i, STORE32p, STORE8p
    O << "] = "; 
    printOperand(MI, 0, O); 
    O << ';'; 
    return;
    break;
  case 37:
    // STORE32fp_nimm7m4
    O << " - "; 
    printOperand(MI, 2, O); 
    O << "] = "; 
    printOperand(MI, 0, O); 
    O << ';'; 
    return;
    break;
  case 38:
    // STORE32p_imm18m4, STORE32p_uimm6m4, STORE8p_imm16
    O << " + "; 
    printOperand(MI, 2, O); 
    O << "] = "; 
    printOperand(MI, 0, O); 
    O << ';'; 
    return;
    break;
  case 39:
    // STORE8fi
    O << "FI b["; 
    printMemoryOperand(MI, 1, O); 
    O << "] = "; 
    printOperand(MI, 0, O); 
    O << ';'; 
    return;
    break;
  }


  // Fragment 2 encoded into 5 bits for 21 unique commands.
  switch ((Bits >> 18) & 31) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADD_RND20, ADDpp
    O << " + "; 
    printOperand(MI, 2, O); 
    break;
  case 1:
    // AND
    O << " & "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 2:
    // LOAD16fi, LOAD32fi
    O << " = ["; 
    printMemoryOperand(MI, 1, O); 
    O << "];"; 
    return;
    break;
  case 3:
    // LOAD16i, LOAD16i_d16, MOVE, MOVECC_zext, SETLEdd, SETLEpp, SETLEri, SE...
    O << ';'; 
    return;
    break;
  case 4:
    // LOAD16pi, LOAD32fp_nimm7m4, LOAD32i, LOAD32p, LOAD32p_16s, LOAD32p_8s,...
    printOperand(MI, 1, O); 
    break;
  case 5:
    // LOAD16s32p_dec, LOAD16s32p_inc, LOAD16s32p_post, LOAD16z32p_dec, LOAD1...
    printOperand(MI, 2, O); 
    break;
  case 6:
    // LOAD8fi
    O << " = B["; 
    printMemoryOperand(MI, 1, O); 
    O << "];"; 
    return;
    break;
  case 7:
    // LOADimm16, LOADimm7, MOVEsext
    O << " (x);"; 
    return;
    break;
  case 8:
    // LOADuimm16, MOVEzext
    O << " (z);"; 
    return;
    break;
  case 9:
    // MOVEsext8
    O << ".b (x);"; 
    return;
    break;
  case 10:
    // MOVEzext8
    O << ".b (z);"; 
    return;
    break;
  case 11:
    // MUL16, MULHS16, MULhh32s, MULhh32u
    O << " * "; 
    printOperand(MI, 2, O); 
    break;
  case 12:
    // OR
    O << " | "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 13:
    // SETULEdd, SETULEpp, SETULEri, SETULEri_not, SETULTdd, SETULTpp, SETULT...
    O << " (iu);"; 
    return;
    break;
  case 14:
    // SLA16r
    O << " BY "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 15:
    // SLAr16
    O << " by "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 16:
    // SLL16i
    O << " << "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 17:
    // SRA16i
    O << " >>> "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 18:
    // SRL16i
    O << " >> "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 19:
    // SUB, SUB16
    O << " - "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  case 20:
    // XOR
    O << " ^ "; 
    printOperand(MI, 2, O); 
    O << ';'; 
    return;
    break;
  }


  // Fragment 3 encoded into 4 bits for 16 unique commands.
  switch ((Bits >> 14) & 15) {
  default:   // unreachable.
  case 0:
    // ADD, ADD16, ADDpp
    O << ';'; 
    return;
    break;
  case 1:
    // ADD_RND20
    O << " (rnd20);"; 
    return;
    break;
  case 2:
    // LOAD16pi, LOAD32i, LOAD32p
    O << "];"; 
    return;
    break;
  case 3:
    // LOAD16s32p_dec, LOAD8s32p_dec
    O << "--] (x);"; 
    return;
    break;
  case 4:
    // LOAD16s32p_inc, LOAD8s32p_inc
    O << "++] (x);"; 
    return;
    break;
  case 5:
    // LOAD16s32p_post, LOAD16z32p_post
    O << "++"; 
    printOperand(MI, 3, O); 
    break;
  case 6:
    // LOAD16z32p_dec, LOAD8z32p_dec
    O << "--] (z);"; 
    return;
    break;
  case 7:
    // LOAD16z32p_inc, LOAD8z32p_inc
    O << "++] (z);"; 
    return;
    break;
  case 8:
    // LOAD32fp_nimm7m4
    O << " - "; 
    printOperand(MI, 2, O); 
    O << "];"; 
    return;
    break;
  case 9:
    // LOAD32i_dec, LOAD32p_dec, LOADhi_dec
    O << "--];"; 
    return;
    break;
  case 10:
    // LOAD32i_inc, LOAD32p_inc, LOADhi_inc
    O << "++];"; 
    return;
    break;
  case 11:
    // LOAD32i_post, LOAD32p_post, LOADhp_post
    O << " ++ "; 
    printOperand(MI, 3, O); 
    O << "];"; 
    return;
    break;
  case 12:
    // LOAD32p_16s, LOAD32p_8s
    O << "] (x);"; 
    return;
    break;
  case 13:
    // LOAD32p_imm16_8s, LOAD32p_imm16_8z, LOAD32p_imm17m2_16s, LOAD32p_imm17...
    O << " + "; 
    printOperand(MI, 2, O); 
    break;
  case 14:
    // MUL16, MULhh32s, MULhh32u
    O << " (is);"; 
    return;
    break;
  case 15:
    // MULHS16
    O << " (ih);"; 
    return;
    break;
  }


  // Fragment 4 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 12) & 3) {
  default:   // unreachable.
  case 0:
    // LOAD16s32p_post, LOAD32p_imm16_8s, LOAD32p_imm17m2_16s, LOAD32p_uimm5m...
    O << "] (x);"; 
    return;
    break;
  case 1:
    // LOAD16z32p_post, LOAD32p_imm16_8z, LOAD32p_imm17m2_16z, LOAD32p_uimm5m...
    O << "] (z);"; 
    return;
    break;
  case 2:
    // LOAD32p_imm18m4, LOAD32p_uimm6m4
    O << "];"; 
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *BlackfinAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 138 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 8, 13, 18, 23, 26, 31, 36, 41, 46, 50, 54, 57, 
    60, 66, 70, 75, 79, 84, 87, 90, 95, 100, 103, 108, 113, 116, 
    121, 126, 129, 134, 139, 142, 149, 157, 164, 167, 172, 177, 180, 185, 
    190, 193, 198, 203, 206, 211, 216, 219, 224, 229, 232, 237, 242, 245, 
    250, 255, 258, 263, 268, 271, 276, 281, 285, 289, 293, 297, 301, 305, 
    308, 313, 318, 321, 326, 331, 334, 339, 344, 347, 352, 357, 361, 364, 
    369, 374, 377, 382, 387, 390, 395, 400, 403, 408, 413, 416, 421, 426, 
    429, 434, 439, 442, 447, 452, 455, 460, 465, 468, 473, 478, 481, 486, 
    491, 494, 499, 504, 507, 512, 517, 520, 525, 530, 533, 538, 543, 548, 
    553, 558, 563, 568, 576, 579, 584, 589, 596, 600, 602, 0
  };

  const char *AsmStrs =
    "a0\000a0.h\000a0.l\000a0.w\000a0.x\000a1\000a1.h\000a1.l\000a1.w\000a1."
    "x\000ac0\000ac1\000an\000aq\000astat\000av0\000av0s\000av1\000av1s\000a"
    "z\000b0\000b0.h\000b0.l\000b1\000b1.h\000b1.l\000b2\000b2.h\000b2.l\000"
    "b3\000b3.h\000b3.l\000cc\000cycles\000cycles2\000emudat\000fp\000fp.h\000"
    "fp.l\000i0\000i0.h\000i0.l\000i1\000i1.h\000i1.l\000i2\000i2.h\000i2.l\000"
    "i3\000i3.h\000i3.l\000l0\000l0.h\000l0.l\000l1\000l1.h\000l1.l\000l2\000"
    "l2.h\000l2.l\000l3\000l3.h\000l3.l\000lb0\000lb1\000lc0\000lc1\000lt0\000"
    "lt1\000m0\000m0.h\000m0.l\000m1\000m1.h\000m1.l\000m2\000m2.h\000m2.l\000"
    "m3\000m3.h\000m3.l\000!cc\000p0\000p0.h\000p0.l\000p1\000p1.h\000p1.l\000"
    "p2\000p2.h\000p2.l\000p3\000p3.h\000p3.l\000p4\000p4.h\000p4.l\000p5\000"
    "p5.h\000p5.l\000r0\000r0.h\000r0.l\000r1\000r1.h\000r1.l\000r2\000r2.h\000"
    "r2.l\000r3\000r3.h\000r3.l\000r4\000r4.h\000r4.l\000r5\000r5.h\000r5.l\000"
    "r6\000r6.h\000r6.l\000r7\000r7.h\000r7.l\000rete\000reti\000retn\000ret"
    "s\000retx\000seqstat\000sp\000sp.h\000sp.l\000syscfg\000usp\000v\000vs\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *BlackfinAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 179 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 157, 161, 167, 177, 185, 191, 202, 219, 234, 242, 250, 257, 261, 
    268, 275, 282, 289, 295, 301, 305, 311, 324, 333, 339, 344, 350, 357, 
    363, 368, 377, 385, 397, 406, 421, 436, 452, 467, 482, 498, 507, 524, 
    532, 544, 556, 569, 579, 587, 599, 611, 622, 633, 645, 662, 679, 699, 
    719, 735, 747, 760, 780, 800, 816, 826, 834, 848, 862, 876, 890, 901, 
    912, 924, 934, 943, 954, 959, 964, 974, 986, 996, 1008, 1019, 1030, 1037, 
    1046, 1056, 1065, 1075, 1081, 1087, 1095, 1104, 1113, 1121, 1125, 1129, 1133, 1138, 
    1141, 1151, 1155, 1160, 1166, 1170, 1178, 1186, 1194, 1206, 1214, 1222, 1230, 1242, 
    1250, 1258, 1266, 1278, 1286, 1295, 1304, 1313, 1326, 1335, 1344, 1353, 1366, 1373, 
    1380, 1387, 1394, 1399, 1404, 1411, 1418, 1423, 1428, 1435, 1440, 1445, 1451, 1455, 
    1465, 1478, 1491, 1505, 1515, 1525, 1543, 1552, 1565, 1578, 1592, 1601, 1614, 1631, 
    1644, 1658, 1675, 1684, 1692, 1704, 1718, 1730, 1734, 1740, 1747, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ABORT\000ADD\000ADD1"
    "6\000ADD_RND20\000ADDimm7\000ADDpp\000ADDpp_imm7\000ADJCALLSTACKDOWN\000"
    "ADJCALLSTACKUP\000ALIGN16\000ALIGN24\000ALIGN8\000AND\000BITCLR\000BITS"
    "ET\000BITTGL\000BITTST\000CALLa\000CALLp\000CLI\000CSYNC\000DISALGNEXCP"
    "T\000EMUEXCPT\000EXCPT\000IDLE\000JUMPa\000JUMPcc\000JUMPp\000LINK\000L"
    "OAD16fi\000LOAD16i\000LOAD16i_d16\000LOAD16pi\000LOAD16s32p_dec\000LOAD"
    "16s32p_inc\000LOAD16s32p_post\000LOAD16z32p_dec\000LOAD16z32p_inc\000LO"
    "AD16z32p_post\000LOAD32fi\000LOAD32fp_nimm7m4\000LOAD32i\000LOAD32i_dec"
    "\000LOAD32i_inc\000LOAD32i_post\000LOAD32imm\000LOAD32p\000LOAD32p_16s\000"
    "LOAD32p_16z\000LOAD32p_8s\000LOAD32p_8z\000LOAD32p_dec\000LOAD32p_imm16"
    "_8s\000LOAD32p_imm16_8z\000LOAD32p_imm17m2_16s\000LOAD32p_imm17m2_16z\000"
    "LOAD32p_imm18m4\000LOAD32p_inc\000LOAD32p_post\000LOAD32p_uimm5m2_16s\000"
    "LOAD32p_uimm5m2_16z\000LOAD32p_uimm6m4\000LOAD32sym\000LOAD8fi\000LOAD8"
    "s32p_dec\000LOAD8s32p_inc\000LOAD8z32p_dec\000LOAD8z32p_inc\000LOADhi_d"
    "ec\000LOADhi_inc\000LOADhp_post\000LOADimm16\000LOADimm7\000LOADuimm16\000"
    "MNOP\000MOVE\000MOVECC_nz\000MOVECC_zext\000MOVENCC_z\000MOVE_cc_ac0\000"
    "MOVE_ccncc\000MOVE_ncccc\000MOVEcc\000MOVEsext\000MOVEsext8\000MOVEzext"
    "\000MOVEzext8\000MUL16\000MUL32\000MULHS16\000MULhh32s\000MULhh32u\000N"
    "BITTST\000NEG\000NOP\000NOT\000ONES\000OR\000OR_ac0_cc\000POP\000PUSH\000"
    "RAISE\000RTS\000SETEQdd\000SETEQpp\000SETEQri\000SETEQri_not\000SETLEdd"
    "\000SETLEpp\000SETLEri\000SETLEri_not\000SETLTdd\000SETLTpp\000SETLTri\000"
    "SETLTri_not\000SETNEdd\000SETULEdd\000SETULEpp\000SETULEri\000SETULEri_"
    "not\000SETULTdd\000SETULTpp\000SETULTri\000SETULTri_not\000SLA16r\000SL"
    "Ar16\000SLL16i\000SLL16r\000SLLi\000SLLr\000SLLr16\000SRA16i\000SRAi\000"
    "SRAr\000SRL16i\000SRLi\000SRLr\000SSYNC\000STI\000STORE16fi\000STORE16i"
    "_dec\000STORE16i_inc\000STORE16p_post\000STORE16pi\000STORE32fi\000STOR"
    "E32fp_nimm7m4\000STORE32i\000STORE32i_dec\000STORE32i_inc\000STORE32i_p"
    "ost\000STORE32p\000STORE32p_dec\000STORE32p_imm18m4\000STORE32p_inc\000"
    "STORE32p_post\000STORE32p_uimm6m4\000STORE8fi\000STORE8p\000STORE8p_dec"
    "\000STORE8p_imm16\000STORE8p_inc\000SUB\000SUB16\000UNLINK\000XOR\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_ALL,
    RC_Accu,
    RC_AnyCC,
    RC_B,
    RC_D,
    RC_D16,
    RC_D16H,
    RC_D16L,
    RC_DP,
    RC_DP16,
    RC_DP16H,
    RC_DP16L,
    RC_GR,
    RC_GR16,
    RC_I,
    RC_JustCC,
    RC_L,
    RC_M,
    RC_NotCC,
    RC_P,
    RC_P16,
    RC_P16H,
    RC_P16L,
    RC_PI,
    RC_StatBit
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_ALL:
    switch (Reg) {
    default: break;
    case BF::R0:
    case BF::R1:
    case BF::R2:
    case BF::R3:
    case BF::R4:
    case BF::R5:
    case BF::R6:
    case BF::R7:
    case BF::P0:
    case BF::P1:
    case BF::P2:
    case BF::P3:
    case BF::P4:
    case BF::P5:
    case BF::I0:
    case BF::I1:
    case BF::I2:
    case BF::I3:
    case BF::M0:
    case BF::M1:
    case BF::M2:
    case BF::M3:
    case BF::B0:
    case BF::B1:
    case BF::B2:
    case BF::B3:
    case BF::L0:
    case BF::L1:
    case BF::L2:
    case BF::L3:
    case BF::FP:
    case BF::SP:
    case BF::A0X:
    case BF::A0W:
    case BF::A1X:
    case BF::A1W:
    case BF::ASTAT:
    case BF::RETS:
    case BF::LC0:
    case BF::LT0:
    case BF::LB0:
    case BF::LC1:
    case BF::LT1:
    case BF::LB1:
    case BF::CYCLES:
    case BF::CYCLES2:
    case BF::USP:
    case BF::SEQSTAT:
    case BF::SYSCFG:
    case BF::RETI:
    case BF::RETX:
    case BF::RETN:
    case BF::RETE:
    case BF::EMUDAT:
      return true;
    }
    break;
  case RC_Accu:
    switch (Reg) {
    default: break;
    case BF::A0:
    case BF::A1:
      return true;
    }
    break;
  case RC_AnyCC:
    switch (Reg) {
    default: break;
    case BF::CC:
    case BF::NCC:
      return true;
    }
    break;
  case RC_B:
    switch (Reg) {
    default: break;
    case BF::B0:
    case BF::B1:
    case BF::B2:
    case BF::B3:
      return true;
    }
    break;
  case RC_D:
    switch (Reg) {
    default: break;
    case BF::R0:
    case BF::R1:
    case BF::R2:
    case BF::R3:
    case BF::R4:
    case BF::R5:
    case BF::R6:
    case BF::R7:
      return true;
    }
    break;
  case RC_D16:
    switch (Reg) {
    default: break;
    case BF::R0H:
    case BF::R0L:
    case BF::R1H:
    case BF::R1L:
    case BF::R2H:
    case BF::R2L:
    case BF::R3H:
    case BF::R3L:
    case BF::R4H:
    case BF::R4L:
    case BF::R5H:
    case BF::R5L:
    case BF::R6H:
    case BF::R6L:
    case BF::R7H:
    case BF::R7L:
      return true;
    }
    break;
  case RC_D16H:
    switch (Reg) {
    default: break;
    case BF::R0H:
    case BF::R1H:
    case BF::R2H:
    case BF::R3H:
    case BF::R4H:
    case BF::R5H:
    case BF::R6H:
    case BF::R7H:
      return true;
    }
    break;
  case RC_D16L:
    switch (Reg) {
    default: break;
    case BF::R0L:
    case BF::R1L:
    case BF::R2L:
    case BF::R3L:
    case BF::R4L:
    case BF::R5L:
    case BF::R6L:
    case BF::R7L:
      return true;
    }
    break;
  case RC_DP:
    switch (Reg) {
    default: break;
    case BF::R0:
    case BF::R1:
    case BF::R2:
    case BF::R3:
    case BF::R4:
    case BF::R5:
    case BF::R6:
    case BF::R7:
    case BF::P0:
    case BF::P1:
    case BF::P2:
    case BF::P3:
    case BF::P4:
    case BF::P5:
    case BF::FP:
    case BF::SP:
      return true;
    }
    break;
  case RC_DP16:
    switch (Reg) {
    default: break;
    case BF::R0H:
    case BF::R0L:
    case BF::R1H:
    case BF::R1L:
    case BF::R2H:
    case BF::R2L:
    case BF::R3H:
    case BF::R3L:
    case BF::R4H:
    case BF::R4L:
    case BF::R5H:
    case BF::R5L:
    case BF::R6H:
    case BF::R6L:
    case BF::R7H:
    case BF::R7L:
    case BF::P0H:
    case BF::P0L:
    case BF::P1H:
    case BF::P1L:
    case BF::P2H:
    case BF::P2L:
    case BF::P3H:
    case BF::P3L:
    case BF::P4H:
    case BF::P4L:
    case BF::P5H:
    case BF::P5L:
    case BF::SPH:
    case BF::SPL:
    case BF::FPH:
    case BF::FPL:
      return true;
    }
    break;
  case RC_DP16H:
    switch (Reg) {
    default: break;
    case BF::R0H:
    case BF::R1H:
    case BF::R2H:
    case BF::R3H:
    case BF::R4H:
    case BF::R5H:
    case BF::R6H:
    case BF::R7H:
    case BF::P0H:
    case BF::P1H:
    case BF::P2H:
    case BF::P3H:
    case BF::P4H:
    case BF::P5H:
    case BF::SPH:
    case BF::FPH:
      return true;
    }
    break;
  case RC_DP16L:
    switch (Reg) {
    default: break;
    case BF::R0L:
    case BF::R1L:
    case BF::R2L:
    case BF::R3L:
    case BF::R4L:
    case BF::R5L:
    case BF::R6L:
    case BF::R7L:
    case BF::P0L:
    case BF::P1L:
    case BF::P2L:
    case BF::P3L:
    case BF::P4L:
    case BF::P5L:
    case BF::SPL:
    case BF::FPL:
      return true;
    }
    break;
  case RC_GR:
    switch (Reg) {
    default: break;
    case BF::R0:
    case BF::R1:
    case BF::R2:
    case BF::R3:
    case BF::R4:
    case BF::R5:
    case BF::R6:
    case BF::R7:
    case BF::P0:
    case BF::P1:
    case BF::P2:
    case BF::P3:
    case BF::P4:
    case BF::P5:
    case BF::I0:
    case BF::I1:
    case BF::I2:
    case BF::I3:
    case BF::M0:
    case BF::M1:
    case BF::M2:
    case BF::M3:
    case BF::B0:
    case BF::B1:
    case BF::B2:
    case BF::B3:
    case BF::L0:
    case BF::L1:
    case BF::L2:
    case BF::L3:
    case BF::FP:
    case BF::SP:
      return true;
    }
    break;
  case RC_GR16:
    switch (Reg) {
    default: break;
    case BF::R0H:
    case BF::R0L:
    case BF::R1H:
    case BF::R1L:
    case BF::R2H:
    case BF::R2L:
    case BF::R3H:
    case BF::R3L:
    case BF::R4H:
    case BF::R4L:
    case BF::R5H:
    case BF::R5L:
    case BF::R6H:
    case BF::R6L:
    case BF::R7H:
    case BF::R7L:
    case BF::P0H:
    case BF::P0L:
    case BF::P1H:
    case BF::P1L:
    case BF::P2H:
    case BF::P2L:
    case BF::P3H:
    case BF::P3L:
    case BF::P4H:
    case BF::P4L:
    case BF::P5H:
    case BF::P5L:
    case BF::SPH:
    case BF::SPL:
    case BF::FPH:
    case BF::FPL:
    case BF::I0H:
    case BF::I0L:
    case BF::I1H:
    case BF::I1L:
    case BF::I2H:
    case BF::I2L:
    case BF::I3H:
    case BF::I3L:
    case BF::M0H:
    case BF::M0L:
    case BF::M1H:
    case BF::M1L:
    case BF::M2H:
    case BF::M2L:
    case BF::M3H:
    case BF::M3L:
    case BF::B0H:
    case BF::B0L:
    case BF::B1H:
    case BF::B1L:
    case BF::B2H:
    case BF::B2L:
    case BF::B3H:
    case BF::B3L:
    case BF::L0H:
    case BF::L0L:
    case BF::L1H:
    case BF::L1L:
    case BF::L2H:
    case BF::L2L:
    case BF::L3H:
    case BF::L3L:
      return true;
    }
    break;
  case RC_I:
    switch (Reg) {
    default: break;
    case BF::I0:
    case BF::I1:
    case BF::I2:
    case BF::I3:
      return true;
    }
    break;
  case RC_JustCC:
    if (Reg == BF::CC)
      return true;
    break;
  case RC_L:
    switch (Reg) {
    default: break;
    case BF::L0:
    case BF::L1:
    case BF::L2:
    case BF::L3:
      return true;
    }
    break;
  case RC_M:
    switch (Reg) {
    default: break;
    case BF::M0:
    case BF::M1:
    case BF::M2:
    case BF::M3:
      return true;
    }
    break;
  case RC_NotCC:
    if (Reg == BF::NCC)
      return true;
    break;
  case RC_P:
    switch (Reg) {
    default: break;
    case BF::P0:
    case BF::P1:
    case BF::P2:
    case BF::P3:
    case BF::P4:
    case BF::P5:
    case BF::FP:
    case BF::SP:
      return true;
    }
    break;
  case RC_P16:
    switch (Reg) {
    default: break;
    case BF::P0H:
    case BF::P0L:
    case BF::P1H:
    case BF::P1L:
    case BF::P2H:
    case BF::P2L:
    case BF::P3H:
    case BF::P3L:
    case BF::P4H:
    case BF::P4L:
    case BF::P5H:
    case BF::P5L:
    case BF::SPH:
    case BF::SPL:
    case BF::FPH:
    case BF::FPL:
      return true;
    }
    break;
  case RC_P16H:
    switch (Reg) {
    default: break;
    case BF::P0H:
    case BF::P1H:
    case BF::P2H:
    case BF::P3H:
    case BF::P4H:
    case BF::P5H:
    case BF::SPH:
    case BF::FPH:
      return true;
    }
    break;
  case RC_P16L:
    switch (Reg) {
    default: break;
    case BF::P0L:
    case BF::P1L:
    case BF::P2L:
    case BF::P3L:
    case BF::P4L:
    case BF::P5L:
    case BF::SPL:
    case BF::FPL:
      return true;
    }
    break;
  case RC_PI:
    switch (Reg) {
    default: break;
    case BF::P0:
    case BF::P1:
    case BF::P2:
    case BF::P3:
    case BF::P4:
    case BF::P5:
    case BF::I0:
    case BF::I1:
    case BF::I2:
    case BF::I3:
    case BF::FP:
    case BF::SP:
      return true;
    }
    break;
  case RC_StatBit:
    switch (Reg) {
    default: break;
    case BF::AZ:
    case BF::AN:
    case BF::CC:
    case BF::AQ:
    case BF::AC0:
    case BF::AC1:
    case BF::AV0:
    case BF::AV0S:
    case BF::AV1:
    case BF::AV1S:
    case BF::V:
    case BF::VS:
      return true;
    }
    break;
  }

  return false;
}

bool BlackfinAsmPrinter::printAliasInstr(const MachineInstr *MI, raw_ostream &OS) {
  return true;
}

#endif // PRINT_ALIAS_INSTR
