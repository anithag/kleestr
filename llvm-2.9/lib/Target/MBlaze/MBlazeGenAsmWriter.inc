//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MBlazeInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    1073741835U,	// ADD
    1073741846U,	// ADDC
    1073741857U,	// ADDI
    1073741868U,	// ADDIC
    1073741879U,	// ADDIK
    1073741879U,	// ADDIK32
    1073741890U,	// ADDIKC
    1073741901U,	// ADDK
    1073741912U,	// ADDKC
    1610612835U,	// ADJCALLSTACKDOWN
    2147483766U,	// ADJCALLSTACKUP
    1207959687U,	// AGET
    1140850834U,	// AGETD
    1073741981U,	// AND
    1107296424U,	// ANDI
    1073742003U,	// ANDN
    1107296446U,	// ANDNI
    1207959753U,	// APUT
    1140850900U,	// APUTD
    1140850911U,	// BEQ
    1140850922U,	// BEQD
    1140850933U,	// BEQI
    1140850944U,	// BEQID
    1140850955U,	// BGE
    1140850966U,	// BGED
    1140850977U,	// BGEI
    1140850988U,	// BGEID
    1140850999U,	// BGT
    1140851010U,	// BGTD
    1140851021U,	// BGTI
    1140851032U,	// BGTID
    1140851043U,	// BLE
    1140851054U,	// BLED
    1140851065U,	// BLEI
    1140851076U,	// BLEID
    1140851087U,	// BLT
    1140851098U,	// BLTD
    1140851109U,	// BLTI
    1140851120U,	// BLTID
    1140851131U,	// BNE
    1140851142U,	// BNED
    1140851153U,	// BNEI
    1140851164U,	// BNEID
    1610613223U,	// BR
    1610613234U,	// BRA
    1610613245U,	// BRAD
    1610613256U,	// BRAI
    1610613267U,	// BRAID
    1140851230U,	// BRALD
    1140851241U,	// BRALID
    1610613300U,	// BRD
    1610613311U,	// BRI
    1610613322U,	// BRID
    1140851285U,	// BRK
    1140851296U,	// BRKI
    1140851307U,	// BRLD
    1140851318U,	// BRLID
    1140851318U,	// BRLID32
    1073742465U,	// BSLL
    1073742476U,	// BSLLI
    1073742487U,	// BSRA
    1073742498U,	// BSRAI
    1073742509U,	// BSRL
    1073742520U,	// BSRLI
    1207960259U,	// CAGET
    1140851406U,	// CAGETD
    1207960281U,	// CAPUT
    1140851428U,	// CAPUTD
    751U,	// CAS32
    1207960329U,	// CGET
    1140851476U,	// CGETD
    1073742623U,	// CMP
    1073742634U,	// CMPU
    1207960373U,	// CPUT
    1140851520U,	// CPUTD
    1207960395U,	// EAGET
    1140851542U,	// EAGETD
    1207960417U,	// ECAGET
    1140851564U,	// ECAGETD
    1207960439U,	// ECGET
    1140851586U,	// ECGETD
    1207960461U,	// EGET
    1140851608U,	// EGETD
    1073742755U,	// FADD
    1073742766U,	// FCMP_EQ
    1073742777U,	// FCMP_GE
    1073742788U,	// FCMP_GT
    1073742799U,	// FCMP_LE
    1073742810U,	// FCMP_LT
    1073742821U,	// FCMP_NE
    1073742832U,	// FCMP_UN
    1073742843U,	// FDIV
    1140851718U,	// FINT
    1140851729U,	// FLT
    1073742876U,	// FMUL
    1073742887U,	// FORI
    1342178354U,	// FRSUB
    1140851773U,	// FSQRT
    1207960648U,	// GET
    1140851795U,	// GETD
    1342178398U,	// IDIV
    1342178409U,	// IDIVU
    1610613876U,	// IMM
    1151U,	// LAA32
    1173U,	// LAD32
    1195U,	// LAN32
    1218U,	// LAO32
    1239U,	// LAS32
    1261U,	// LAX32
    1476396291U,	// LBU
    1476396302U,	// LBUI
    1476396313U,	// LBUR
    1476396324U,	// LHU
    1476396335U,	// LHUI
    1476396346U,	// LHUR
    1476396357U,	// LW
    1476396368U,	// LWF
    1476396380U,	// LWFI
    1476396392U,	// LWI
    1476396403U,	// LWR
    1476396414U,	// LWX
    1417U,	// MEMBARRIER
    1140852122U,	// MFS
    1140852133U,	// MSRCLR
    1140852144U,	// MSRSET
    1140852155U,	// MTS
    1073743302U,	// MUL
    1073743313U,	// MULH
    1073743324U,	// MULHSU
    1073743335U,	// MULHU
    1073743346U,	// MULI
    1207961085U,	// NAGET
    1140852232U,	// NAGETD
    1207961107U,	// NAPUT
    1140852254U,	// NAPUTD
    1207961129U,	// NCAGET
    1140852276U,	// NCAGETD
    1207961151U,	// NCAPUT
    1140852298U,	// NCAPUTD
    1207961173U,	// NCGET
    1140852320U,	// NCGETD
    1207961195U,	// NCPUT
    1140852342U,	// NCPUTD
    1207961217U,	// NEAGET
    1140852364U,	// NEAGETD
    1207961239U,	// NECAGET
    1140852386U,	// NECAGETD
    1207961261U,	// NECGET
    1140852408U,	// NECGETD
    1207961283U,	// NEGET
    1140852430U,	// NEGETD
    1207961305U,	// NGET
    1140852452U,	// NGETD
    1775U,	// NOP
    1207961335U,	// NPUT
    1140852482U,	// NPUTD
    1073743629U,	// OR
    1107297319U,	// ORI
    1107297319U,	// ORI32
    1073743640U,	// PCMPBF
    1073743651U,	// PCMPEQ
    1073743662U,	// PCMPNE
    1207961401U,	// PUT
    1140852548U,	// PUTD
    1342179151U,	// RSUB
    1342179162U,	// RSUBC
    1342179173U,	// RSUBI
    1342179184U,	// RSUBIC
    1342179195U,	// RSUBIK
    1342179206U,	// RSUBIKC
    1342179217U,	// RSUBK
    1342179228U,	// RSUBKC
    1140852647U,	// RTBD
    1140852658U,	// RTED
    1140852669U,	// RTID
    1140852680U,	// RTSD
    1476397011U,	// SB
    1476397022U,	// SBI
    1476397033U,	// SBR
    1140852724U,	// SEXT16
    1140852735U,	// SEXT8
    1476397066U,	// SH
    1476397077U,	// SHI
    1476397088U,	// SHR
    1140852779U,	// SRA
    1140852790U,	// SRC
    1140852801U,	// SRL
    1476397132U,	// SW
    1476397143U,	// SWF
    1476397155U,	// SWFI
    1476397167U,	// SWI
    2170U,	// SWP32
    1476397192U,	// SWR
    1476397203U,	// SWX
    2206U,	// Select_CC
    2226U,	// Select_FCC
    2247U,	// ShiftL
    2264U,	// ShiftRA
    2282U,	// ShiftRL
    1207961852U,	// TAGET
    1140852999U,	// TAGETD
    3221227794U,	// TAPUT
    1610615069U,	// TAPUTD
    1207961896U,	// TCAGET
    1140853043U,	// TCAGETD
    3221227838U,	// TCAPUT
    1610615113U,	// TCAPUTD
    1207961940U,	// TCGET
    1140853087U,	// TCGETD
    3221227882U,	// TCPUT
    1610615157U,	// TCPUTD
    1207961984U,	// TEAGET
    1140853131U,	// TEAGETD
    1207962006U,	// TECAGET
    1140853153U,	// TECAGETD
    1207962028U,	// TECGET
    1140853175U,	// TECGETD
    1207962050U,	// TEGET
    1140853197U,	// TEGETD
    1207962072U,	// TGET
    1140853219U,	// TGETD
    1207962094U,	// TNAGET
    1140853241U,	// TNAGETD
    3221228036U,	// TNAPUT
    1610615311U,	// TNAPUTD
    1207962138U,	// TNCAGET
    1140853285U,	// TNCAGETD
    3221228080U,	// TNCAPUT
    1610615355U,	// TNCAPUTD
    1207962182U,	// TNCGET
    1140853329U,	// TNCGETD
    3221228124U,	// TNCPUT
    1610615399U,	// TNCPUTD
    1207962226U,	// TNEAGET
    1140853373U,	// TNEAGETD
    1207962248U,	// TNECAGET
    1140853395U,	// TNECAGETD
    1207962270U,	// TNECGET
    1140853417U,	// TNECGETD
    1207962292U,	// TNEGET
    1140853439U,	// TNEGETD
    1207962314U,	// TNGET
    1140853461U,	// TNGETD
    3221228256U,	// TNPUT
    1610615531U,	// TNPUTD
    3221228278U,	// TPUT
    1610615553U,	// TPUTD
    1140853516U,	// WDC
    1140853527U,	// WDCC
    1140853538U,	// WDCF
    1140853549U,	// WIC
    1073744696U,	// XOR
    1107299139U,	// XORI
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000add       \000addc      \000addi      \000addic     \000ad"
    "dik     \000addikc    \000addk      \000addkc     \000#ADJCALLSTACKDOWN"
    " \000#ADJCALLSTACKUP \000aget      \000agetd     \000and       \000andi"
    "      \000andn      \000andni     \000aput      \000aputd     \000beq  "
    "     \000beqd      \000beqi      \000beqid     \000bge       \000bged  "
    "    \000bgei      \000bgeid     \000bgt       \000bgtd      \000bgti   "
    "   \000bgtid     \000ble       \000bled      \000blei      \000bleid   "
    "  \000blt       \000bltd      \000blti      \000bltid     \000bne      "
    " \000bned      \000bnei      \000bneid     \000br        \000bra       "
    "\000brad      \000brai      \000braid     \000brald     \000bralid    \000"
    "brd       \000bri       \000brid      \000brk       \000brki      \000b"
    "rld      \000brlid     \000bsll      \000bslli     \000bsra      \000bs"
    "rai     \000bsrl      \000bsrli     \000caget     \000cagetd    \000cap"
    "ut     \000caputd    \000# atomic compare and swap\000cget      \000cge"
    "td     \000cmp       \000cmpu      \000cput      \000cputd     \000eage"
    "t     \000eagetd    \000ecaget    \000ecagetd   \000ecget     \000ecget"
    "d    \000eget      \000egetd     \000fadd      \000fcmp.eq   \000fcmp.g"
    "e   \000fcmp.gt   \000fcmp.le   \000fcmp.lt   \000fcmp.ne   \000fcmp.un"
    "   \000fdiv      \000fint      \000flt       \000fmul      \000ori     "
    "  \000frsub     \000fsqrt     \000get       \000getd      \000idiv     "
    " \000idivu     \000imm       \000# atomic load and add\000# atomic load"
    " and and\000# atomic load and nand\000# atomic load and or\000# atomic "
    "load and sub\000# atomic load and xor\000lbu       \000lbui      \000lb"
    "ur      \000lhu       \000lhui      \000lhur      \000lw        \000lw "
    "        \000lwi        \000lwi       \000lwr       \000lwx       \000# "
    "memory barrier\000mfs       \000msrclr    \000msrset    \000mts       \000"
    "mul       \000mulh      \000mulhsu    \000mulhu     \000muli      \000n"
    "aget     \000nagetd    \000naput     \000naputd    \000ncaget    \000nc"
    "agetd   \000ncaput    \000ncaputd   \000ncget     \000ncgetd    \000ncp"
    "ut     \000ncputd    \000neaget    \000neagetd   \000necaget   \000neca"
    "getd  \000necget    \000necgetd   \000neget     \000negetd    \000nget "
    "     \000ngetd     \000nop    \000nput      \000nputd     \000or       "
    " \000pcmpbf    \000pcmpeq    \000pcmpne    \000put       \000putd      "
    "\000rsub      \000rsubc     \000rsubi     \000rsubic    \000rsubik    \000"
    "rsubikc   \000rsubk     \000rsubkc    \000rtbd      \000rted      \000r"
    "tid      \000rtsd      \000sb        \000sbi       \000sbr       \000se"
    "xt16    \000sext8     \000sh        \000shi       \000shr       \000sra"
    "       \000src       \000srl       \000sw        \000sw         \000swi"
    "        \000swi       \000# atomic swap\000swr       \000swx       \000"
    "; SELECT_CC PSEUDO!\000; SELECT_FCC PSEUDO!\000; ShiftL PSEUDO!\000; Sh"
    "iftRA PSEUDO!\000; ShiftRL PSEUDO!\000taget     \000tagetd    \000taput"
    "     \000taputd    \000tcaget    \000tcagetd   \000tcaput    \000tcaput"
    "d   \000tcget     \000tcgetd    \000tcput     \000tcputd    \000teaget "
    "   \000teagetd   \000tecaget   \000tecagetd  \000tecget    \000tecgetd "
    "  \000teget     \000tegetd    \000tget      \000tgetd     \000tnaget   "
    " \000tnagetd   \000tnaput    \000tnaputd   \000tncaget   \000tncagetd  "
    "\000tncaput   \000tncaputd  \000tncget    \000tncgetd   \000tncput    \000"
    "tncputd   \000tneaget   \000tneagetd  \000tnecaget  \000tnecagetd \000t"
    "necget   \000tnecgetd  \000tneget    \000tnegetd   \000tnget     \000tn"
    "getd    \000tnput     \000tnputd    \000tput      \000tputd     \000wdc"
    "       \000wdc.clear \000wdc.flush \000wic       \000xor       \000xori"
    "      \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 4095)-1;


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 30) & 3) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, CAS32, LAA32, LAD32, LAN32, LAO32, LAS32, LAX32, MEMBARRIER...
    return;
    break;
  case 1:
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, ADJCALLST...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKUP
    printUnsignedImm(MI, 0, O); 
    return;
    break;
  case 3:
    // TAPUT, TCAPUT, TCPUT, TNAPUT, TNCAPUT, TNCPUT, TNPUT, TPUT
    printFSLImm(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 29) & 1) {
    // ADJCALLSTACKDOWN, BR, BRA, BRAD, BRAI, BRAID, BRD, BRI, BRID, IMM, TAP...
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AGET, AGE...
    O << ", "; 
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 27) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AGETD, AN...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // AGET, APUT, CAGET, CAPUT, CGET, CPUT, EAGET, ECAGET, ECGET, EGET, GET,...
    printFSLImm(MI, 1, O); 
    return;
    break;
  case 2:
    // FRSUB, IDIV, IDIVU, RSUB, RSUBC, RSUBI, RSUBIC, RSUBIK, RSUBIKC, RSUBK...
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // LBU, LBUI, LBUR, LHU, LHUI, LHUR, LW, LWF, LWFI, LWI, LWR, LWX, SB, SB...
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 26) & 1) {
    // AGETD, APUTD, BEQ, BEQD, BEQI, BEQID, BGE, BGED, BGEI, BGEID, BGT, BGT...
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AND, ANDI...
    O << ", "; 
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 25) & 1) {
    // ANDI, ANDNI, ORI, ORI32, XORI
    printUnsignedImm(MI, 2, O); 
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AND, ANDN...
    printOperand(MI, 2, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MBlazeInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 58 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 42, 46, 
    50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 
    106, 110, 114, 118, 122, 126, 131, 136, 141, 146, 151, 156, 160, 165, 
    171, 177, 183, 189, 195, 201, 207, 213, 219, 225, 232, 239, 246, 253, 
    259, 0
  };

  const char *AsmStrs =
    "rmsr[c]\000r0\000r1\000r2\000r3\000r4\000r5\000r6\000r7\000r8\000r9\000"
    "r10\000r11\000r12\000r13\000r14\000r15\000r16\000r17\000r18\000r19\000r"
    "20\000r21\000r22\000r23\000r24\000r25\000r26\000r27\000r28\000r29\000r3"
    "0\000r31\000rbtr\000rear\000redr\000resr\000rfsr\000rmsr\000rpc\000rpid"
    "\000rpvr0\000rpvr1\000rpvr2\000rpvr3\000rpvr4\000rpvr5\000rpvr6\000rpvr"
    "7\000rpvr8\000rpvr9\000rpvr10\000rpvr11\000rtlbhi\000rtlblo\000rtlbx\000"
    "rzpr\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MBlazeInstPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 267 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 155, 160, 165, 171, 177, 185, 192, 197, 203, 220, 235, 240, 246, 
    250, 255, 260, 266, 271, 277, 281, 286, 291, 297, 301, 306, 311, 317, 
    321, 326, 331, 337, 341, 346, 351, 357, 361, 366, 371, 377, 381, 386, 
    391, 397, 400, 404, 409, 414, 420, 426, 433, 437, 441, 446, 450, 455, 
    460, 466, 474, 479, 485, 490, 496, 501, 507, 513, 520, 526, 533, 539, 
    544, 550, 554, 559, 564, 570, 576, 583, 590, 598, 604, 611, 616, 622, 
    627, 635, 643, 651, 659, 667, 675, 683, 688, 693, 697, 702, 707, 713, 
    719, 723, 728, 733, 739, 743, 749, 755, 761, 767, 773, 779, 783, 788, 
    793, 797, 802, 807, 810, 814, 819, 823, 827, 831, 842, 846, 853, 860, 
    864, 868, 873, 880, 886, 891, 897, 904, 910, 917, 924, 932, 939, 947, 
    953, 960, 966, 973, 980, 988, 996, 1005, 1012, 1020, 1026, 1033, 1038, 1044, 
    1048, 1053, 1059, 1062, 1066, 1072, 1079, 1086, 1093, 1097, 1102, 1107, 1113, 1119, 
    1126, 1133, 1141, 1147, 1154, 1159, 1164, 1169, 1174, 1177, 1181, 1185, 1192, 1198, 
    1201, 1205, 1209, 1213, 1217, 1221, 1224, 1228, 1233, 1237, 1243, 1247, 1251, 1261, 
    1272, 1279, 1287, 1295, 1301, 1308, 1314, 1321, 1328, 1336, 1343, 1351, 1357, 1364, 
    1370, 1377, 1384, 1392, 1400, 1409, 1416, 1424, 1430, 1437, 1442, 1448, 1455, 1463, 
    1470, 1478, 1486, 1495, 1503, 1512, 1519, 1527, 1534, 1542, 1550, 1559, 1568, 1578, 
    1586, 1595, 1602, 1610, 1616, 1623, 1629, 1636, 1641, 1647, 1651, 1656, 1661, 1665, 
    1669, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADD\000ADDC\000ADDI\000"
    "ADDIC\000ADDIK\000ADDIK32\000ADDIKC\000ADDK\000ADDKC\000ADJCALLSTACKDOW"
    "N\000ADJCALLSTACKUP\000AGET\000AGETD\000AND\000ANDI\000ANDN\000ANDNI\000"
    "APUT\000APUTD\000BEQ\000BEQD\000BEQI\000BEQID\000BGE\000BGED\000BGEI\000"
    "BGEID\000BGT\000BGTD\000BGTI\000BGTID\000BLE\000BLED\000BLEI\000BLEID\000"
    "BLT\000BLTD\000BLTI\000BLTID\000BNE\000BNED\000BNEI\000BNEID\000BR\000B"
    "RA\000BRAD\000BRAI\000BRAID\000BRALD\000BRALID\000BRD\000BRI\000BRID\000"
    "BRK\000BRKI\000BRLD\000BRLID\000BRLID32\000BSLL\000BSLLI\000BSRA\000BSR"
    "AI\000BSRL\000BSRLI\000CAGET\000CAGETD\000CAPUT\000CAPUTD\000CAS32\000C"
    "GET\000CGETD\000CMP\000CMPU\000CPUT\000CPUTD\000EAGET\000EAGETD\000ECAG"
    "ET\000ECAGETD\000ECGET\000ECGETD\000EGET\000EGETD\000FADD\000FCMP_EQ\000"
    "FCMP_GE\000FCMP_GT\000FCMP_LE\000FCMP_LT\000FCMP_NE\000FCMP_UN\000FDIV\000"
    "FINT\000FLT\000FMUL\000FORI\000FRSUB\000FSQRT\000GET\000GETD\000IDIV\000"
    "IDIVU\000IMM\000LAA32\000LAD32\000LAN32\000LAO32\000LAS32\000LAX32\000L"
    "BU\000LBUI\000LBUR\000LHU\000LHUI\000LHUR\000LW\000LWF\000LWFI\000LWI\000"
    "LWR\000LWX\000MEMBARRIER\000MFS\000MSRCLR\000MSRSET\000MTS\000MUL\000MU"
    "LH\000MULHSU\000MULHU\000MULI\000NAGET\000NAGETD\000NAPUT\000NAPUTD\000"
    "NCAGET\000NCAGETD\000NCAPUT\000NCAPUTD\000NCGET\000NCGETD\000NCPUT\000N"
    "CPUTD\000NEAGET\000NEAGETD\000NECAGET\000NECAGETD\000NECGET\000NECGETD\000"
    "NEGET\000NEGETD\000NGET\000NGETD\000NOP\000NPUT\000NPUTD\000OR\000ORI\000"
    "ORI32\000PCMPBF\000PCMPEQ\000PCMPNE\000PUT\000PUTD\000RSUB\000RSUBC\000"
    "RSUBI\000RSUBIC\000RSUBIK\000RSUBIKC\000RSUBK\000RSUBKC\000RTBD\000RTED"
    "\000RTID\000RTSD\000SB\000SBI\000SBR\000SEXT16\000SEXT8\000SH\000SHI\000"
    "SHR\000SRA\000SRC\000SRL\000SW\000SWF\000SWFI\000SWI\000SWP32\000SWR\000"
    "SWX\000Select_CC\000Select_FCC\000ShiftL\000ShiftRA\000ShiftRL\000TAGET"
    "\000TAGETD\000TAPUT\000TAPUTD\000TCAGET\000TCAGETD\000TCAPUT\000TCAPUTD"
    "\000TCGET\000TCGETD\000TCPUT\000TCPUTD\000TEAGET\000TEAGETD\000TECAGET\000"
    "TECAGETD\000TECGET\000TECGETD\000TEGET\000TEGETD\000TGET\000TGETD\000TN"
    "AGET\000TNAGETD\000TNAPUT\000TNAPUTD\000TNCAGET\000TNCAGETD\000TNCAPUT\000"
    "TNCAPUTD\000TNCGET\000TNCGETD\000TNCPUT\000TNCPUTD\000TNEAGET\000TNEAGE"
    "TD\000TNECAGET\000TNECAGETD\000TNECGET\000TNECGETD\000TNEGET\000TNEGETD"
    "\000TNGET\000TNGETD\000TNPUT\000TNPUTD\000TPUT\000TPUTD\000WDC\000WDCC\000"
    "WDCF\000WIC\000XOR\000XORI\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_CRC,
    RC_GPR,
    RC_SPR
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_CRC:
    if (Reg == MBlaze::CARRY)
      return true;
    break;
  case RC_GPR:
    switch (Reg) {
    default: break;
    case MBlaze::R3:
    case MBlaze::R4:
    case MBlaze::R5:
    case MBlaze::R6:
    case MBlaze::R7:
    case MBlaze::R8:
    case MBlaze::R9:
    case MBlaze::R10:
    case MBlaze::R11:
    case MBlaze::R12:
    case MBlaze::R20:
    case MBlaze::R21:
    case MBlaze::R22:
    case MBlaze::R23:
    case MBlaze::R24:
    case MBlaze::R25:
    case MBlaze::R26:
    case MBlaze::R27:
    case MBlaze::R28:
    case MBlaze::R29:
    case MBlaze::R30:
    case MBlaze::R31:
    case MBlaze::R0:
    case MBlaze::R1:
    case MBlaze::R2:
    case MBlaze::R13:
    case MBlaze::R14:
    case MBlaze::R15:
    case MBlaze::R16:
    case MBlaze::R17:
    case MBlaze::R18:
    case MBlaze::R19:
      return true;
    }
    break;
  case RC_SPR:
    switch (Reg) {
    default: break;
    case MBlaze::RPC:
    case MBlaze::RMSR:
    case MBlaze::REAR:
    case MBlaze::RESR:
    case MBlaze::RFSR:
    case MBlaze::RBTR:
    case MBlaze::REDR:
    case MBlaze::RPID:
    case MBlaze::RZPR:
    case MBlaze::RTLBX:
    case MBlaze::RTLBLO:
    case MBlaze::RTLBHI:
    case MBlaze::RPVR0:
    case MBlaze::RPVR1:
    case MBlaze::RPVR2:
    case MBlaze::RPVR3:
    case MBlaze::RPVR4:
    case MBlaze::RPVR5:
    case MBlaze::RPVR6:
    case MBlaze::RPVR7:
    case MBlaze::RPVR8:
    case MBlaze::RPVR9:
    case MBlaze::RPVR10:
    case MBlaze::RPVR11:
      return true;
    }
    break;
  }

  return false;
}

bool MBlazeInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return true;
}

#endif // PRINT_ALIAS_INSTR
